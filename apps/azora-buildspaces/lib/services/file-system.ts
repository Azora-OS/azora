/**
 * File System Service
 * 
 * Provides file system operations, Git integration, and workspace management
 * for containerized development environments.
 */

import { z } from 'zod'
import { EventEmitter } from 'events'
import { azoraPilotClient } from './ai-pilot-client'
import { constitutionalAI, UserActionType, UserAction } from './constitutional-ai'

// File System Schemas
const FileEntrySchema = z.object({
  name: z.string(),
  path: z.string(),
  type: z.enum(['file', 'directory']),
  size: z.number().optional(),
  modified: z.date(),
  permissions: z.string().optional(),
  isHidden: z.boolean().default(false),
  isSymlink: z.boolean().default(false),
  children: z.array(z.lazy(() => FileEntrySchema)).optional()
})

const GitStatusSchema = z.object({
  branch: z.string(),
  ahead: z.number().default(0),
  behind: z.number().default(0),
  staged: z.array(z.string()).default([]),
  unstaged: z.array(z.string()).default([]),
  untracked: z.array(z.string()).default([]),
  conflicted: z.array(z.string()).default([]),
  clean: z.boolean().default(true)
})

const GitCommitSchema = z.object({
  hash: z.string(),
  author: z.string(),
  email: z.string(),
  date: z.date(),
  message: z.string(),
  files: z.array(z.string()).default([])
})

// Types
export type FileEntry = z.infer<typeof FileEntrySchema>
export type GitStatus = z.infer<typeof GitStatusSchema>
export type GitCommit = z.infer<typeof GitCommitSchema>

export interface FileWatcher {
  path: string
  recursive: boolean
  callback: (event: FileSystemEvent) => void
}

export interface FileSystemEvent {
  type: 'created' | 'modified' | 'deleted' | 'renamed'
  path: string
  oldPath?: string
  timestamp: Date
}

export interface GitRemote {
  name: string
  url: string
  type: 'fetch' | 'push'
}

/**
 * File System Service
 * 
 * Manages file operations and Git integration
 */
export class FileSystemService extends EventEmitter {
  private watchers: Map<string, FileWatcher[]> = new Map()
  private gitRepositories: Map<string, GitRepository> = new Map()

  constructor() {
    super()
  }

  /**
   * List directory contents
   */
  async listDirectory(containerId: string, path: string, showHidden = false): Promise<FileEntry[]> {
    try {
      // Mock directory listing
      const entries: FileEntry[] = [
        {
          name: 'package.json',
          path: `${path}/package.json`,
          type: 'file',
          size: 1024,
          modified: new Date(),
          permissions: 'rw-r--r--'
        },
        {
          name: 'src',
          path: `${path}/src`,
          type: 'directory',
          modified: new Date(),
          permissions: 'rwxr-xr-x',
          children: [
            {
              name: 'index.ts',
              path: `${path}/src/index.ts`,
              type: 'file',
              size: 512,
              modified: new Date(),
              permissions: 'rw-r--r--'
            }
          ]
        },
        {
          name: 'README.md',
          path: `${path}/README.md`,
          type: 'file',
          size: 2048,
          modified: new Date(),
          permissions: 'rw-r--r--'
        }
      ]

      if (showHidden) {
        entries.push({
          name: '.git',
          path: `${path}/.git`,
          type: 'directory',
          modified: new Date(),
          permissions: 'rwxr-xr-x',
          isHidden: true
        })
      }

      return entries.filter(entry => showHidden || !entry.isHidden)
    } catch (error) {
      throw new Error(`Failed to list directory: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }
  }

  /**
   * Read file content
   */
  async readFile(containerId: string, filePath: string): Promise<string> {
    try {
      // Mock file reading
      if (filePath.endsWith('package.json')) {
        return JSON.stringify({
          name: 'buildspaces-project',
          version: '1.0.0',
          description: 'A project created in Buildspaces',
          main: 'src/index.ts',
          scripts: {
            start: 'node src/index.js',
            build: 'tsc',
            test: 'jest'
          },
          dependencies: {
            typescript: '^4.9.0'
          }
        }, null, 2)
      }

      if (filePath.endsWith('README.md')) {
        return `# Buildspaces Project

This project was created in Azora Buildspaces.

## Getting Started

\`\`\`bash
npm install
npm start
\`\`\`
`
      }

      if (filePath.endsWith('.ts') || filePath.endsWith('.js')) {
        return `// Generated by Buildspaces
console.log('Hello from Buildspaces!');

export default function main() {
  console.log('Application started');
}
`
      }

      return 'File content placeholder'
    } catch (error) {
      throw new Error(`Failed to read file: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }
  }

  /**
   * Write file content
   */
  async writeFile(containerId: string, filePath: string, content: string): Promise<void> {
    try {
      // Mock file writing
      await new Promise(resolve => setTimeout(resolve, 100))

      this.emit('fileChanged', {
        type: 'modified',
        path: filePath,
        timestamp: new Date()
      } as FileSystemEvent)

      // Optional: Auto-ingest file content into Azora Pilot for RAG/provenance
      if (process.env.AZORA_PILOT_AUTOMATIC_INGEST === 'true') {
        // Ingest in background and ignore failures
        try { await azoraPilotClient.ingest(content, filePath) } catch (e) { /* swallow */ }
      }

    } catch (error) {
      throw new Error(`Failed to write file: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }
  }

  /**
   * Create directory
   */
  async createDirectory(containerId: string, dirPath: string): Promise<void> {
    try {
      // Mock directory creation
      await new Promise(resolve => setTimeout(resolve, 50))

      this.emit('fileChanged', {
        type: 'created',
        path: dirPath,
        timestamp: new Date()
      } as FileSystemEvent)

    } catch (error) {
      throw new Error(`Failed to create directory: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }
  }

  /**
   * Delete file or directory
   */
  async delete(containerId: string, path: string): Promise<void> {
    try {
      // Mock deletion
      await new Promise(resolve => setTimeout(resolve, 100))

      this.emit('fileChanged', {
        type: 'deleted',
        path,
        timestamp: new Date()
      } as FileSystemEvent)

    } catch (error) {
      throw new Error(`Failed to delete: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }
  }

  /**
   * Rename file or directory
   */
  async rename(containerId: string, oldPath: string, newPath: string): Promise<void> {
    try {
      // Mock rename
      await new Promise(resolve => setTimeout(resolve, 100))

      this.emit('fileChanged', {
        type: 'renamed',
        path: newPath,
        oldPath,
        timestamp: new Date()
      } as FileSystemEvent)

    } catch (error) {
      throw new Error(`Failed to rename: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }
  }

  /**
   * Watch file system changes
   */
  watchPath(containerId: string, path: string, recursive = true, callback: (event: FileSystemEvent) => void): string {
    const watcherId = `watcher_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    
    const watcher: FileWatcher = {
      path,
      recursive,
      callback
    }

    if (!this.watchers.has(containerId)) {
      this.watchers.set(containerId, [])
    }

    this.watchers.get(containerId)!.push(watcher)

    // Listen to file change events
    this.on('fileChanged', (event: FileSystemEvent) => {
      if (event.path.startsWith(path) || (recursive && event.path.includes(path))) {
        callback(event)
      }
    })

    return watcherId
  }

  /**
   * Stop watching path
   */
  unwatchPath(containerId: string, watcherId: string): void {
    const watchers = this.watchers.get(containerId)
    if (watchers) {
      const index = watchers.findIndex(w => w.path === watcherId)
      if (index !== -1) {
        watchers.splice(index, 1)
      }
    }
  }

  /**
   * Initialize Git repository
   */
  async initGitRepository(containerId: string, path: string): Promise<void> {
    try {
      const repo = new GitRepository(containerId, path)
      await repo.init()
      
      this.gitRepositories.set(`${containerId}:${path}`, repo)

      this.emit('gitRepositoryInitialized', { containerId, path })

    } catch (error) {
      throw new Error(`Failed to initialize Git repository: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }
  }

  /**
   * Get Git status
   */
  async getGitStatus(containerId: string, path: string): Promise<GitStatus> {
    const repo = this.gitRepositories.get(`${containerId}:${path}`)
    if (!repo) {
      throw new Error('Git repository not found')
    }

    return await repo.getStatus()
  }

  /**
   * Stage files for commit
   */
  async gitAdd(containerId: string, path: string, files: string[]): Promise<void> {
    const repo = this.gitRepositories.get(`${containerId}:${path}`)
    if (!repo) {
      throw new Error('Git repository not found')
    }

    await repo.add(files)
  }

  /**
   * Commit changes
   */
  async gitCommit(containerId: string, path: string, message: string, author?: { name: string; email: string }): Promise<string> {
    const repo = this.gitRepositories.get(`${containerId}:${path}`)
    if (!repo) {
      throw new Error('Git repository not found')
    }

    return await repo.commit(message, author)
  }

  /**
   * Get commit history
   */
  async getGitHistory(containerId: string, path: string, limit = 50): Promise<GitCommit[]> {
    const repo = this.gitRepositories.get(`${containerId}:${path}`)
    if (!repo) {
      throw new Error('Git repository not found')
    }

    return await repo.getHistory(limit)
  }

  /**
   * Create new branch
   */
  async createBranch(containerId: string, path: string, branchName: string): Promise<void> {
    const repo = this.gitRepositories.get(`${containerId}:${path}`)
    if (!repo) {
      throw new Error('Git repository not found')
    }

    await repo.createBranch(branchName)
  }

  /**
   * Switch branch
   */
  async switchBranch(containerId: string, path: string, branchName: string): Promise<void> {
    const repo = this.gitRepositories.get(`${containerId}:${path}`)
    if (!repo) {
      throw new Error('Git repository not found')
    }

    await repo.switchBranch(branchName)
  }

  /**
   * Add remote repository
   */
  async addRemote(containerId: string, path: string, name: string, url: string): Promise<void> {
    const repo = this.gitRepositories.get(`${containerId}:${path}`)
    if (!repo) {
      throw new Error('Git repository not found')
    }

    await repo.addRemote(name, url)
  }

  /**
   * Push to remote
   */
  async gitPush(containerId: string, path: string, remote = 'origin', branch?: string, userId?: string): Promise<void> {
    const repo = this.gitRepositories.get(`${containerId}:${path}`)
    if (!repo) {
      throw new Error('Git repository not found')
    }

    await repo.push(remote, branch, userId)
  }

  /**
   * Pull from remote
   */
  async gitPull(containerId: string, path: string, remote = 'origin', branch?: string): Promise<void> {
    const repo = this.gitRepositories.get(`${containerId}:${path}`)
    if (!repo) {
      throw new Error('Git repository not found')
    }

    await repo.pull(remote, branch)
  }
}

/**
 * Git Repository
 * 
 * Manages Git operations for a specific repository
 */
class GitRepository {
  private containerId: string
  private path: string
  private currentBranch = 'main'
  private remotes: Map<string, GitRemote> = new Map()
  private commits: GitCommit[] = []

  constructor(containerId: string, path: string) {
    this.containerId = containerId
    this.path = path
  }

  async init(): Promise<void> {
    // Mock Git init
    await new Promise(resolve => setTimeout(resolve, 100))
    
    // Create initial commit
    const initialCommit: GitCommit = {
      hash: this.generateCommitHash(),
      author: 'Buildspaces User',
      email: 'user@buildspaces.dev',
      date: new Date(),
      message: 'Initial commit',
      files: []
    }
    
    this.commits.push(initialCommit)
  }

  async getStatus(): Promise<GitStatus> {
    // Mock Git status
    return {
      branch: this.currentBranch,
      ahead: 0,
      behind: 0,
      staged: [],
      unstaged: ['src/index.ts'],
      untracked: ['new-file.txt'],
      conflicted: [],
      clean: false
    }
  }

  async add(files: string[]): Promise<void> {
    // Mock Git add
    await new Promise(resolve => setTimeout(resolve, 50))
  }

  async commit(message: string, author?: { name: string; email: string }): Promise<string> {
    // Mock Git commit
    const commit: GitCommit = {
      hash: this.generateCommitHash(),
      author: author?.name || 'Buildspaces User',
      email: author?.email || 'user@buildspaces.dev',
      date: new Date(),
      message,
      files: ['src/index.ts', 'package.json']
    }

    this.commits.unshift(commit)
    
    await new Promise(resolve => setTimeout(resolve, 100))
    
    return commit.hash
  }

  async getHistory(limit: number): Promise<GitCommit[]> {
    return this.commits.slice(0, limit)
  }

  async createBranch(branchName: string): Promise<void> {
    // Mock branch creation
    await new Promise(resolve => setTimeout(resolve, 50))
  }

  async switchBranch(branchName: string): Promise<void> {
    this.currentBranch = branchName
    await new Promise(resolve => setTimeout(resolve, 50))
  }

  async addRemote(name: string, url: string): Promise<void> {
    this.remotes.set(name, {
      name,
      url,
      type: 'fetch'
    })
    
    await new Promise(resolve => setTimeout(resolve, 50))
  }

  async push(remote: string, branch?: string): Promise<void> {
    // In this mock we do a constitutional verification for push operations
    // Note: userId may be attached by caller via optional param
    // (signature updated by FileSystemService.gitPush)
    const userId = (arguments.length >= 3 && typeof (arguments as any)[2] === 'string') ? (arguments as any)[2] : 'unknown'

    const action: UserAction = {
      id: `action_push_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      userId,
      type: UserActionType.PROJECT_PUSH,
      payload: { path: this.path, remote, branch },
      timestamp: new Date(),
      sessionId: `session_push_${Date.now()}`
    }

    const verification = await constitutionalAI.verifyAction(action)

    await constitutionalAI.auditLog({
      id: verification.auditId,
      timestamp: new Date(),
      userId: action.userId,
      action,
      result: verification,
      constitutionalScore: verification.score,
      violations: verification.violations,
      status: verification.allowed ? 'COMPLIANT' : 'VIOLATION'
    })

    if (!verification.allowed) {
      throw new Error(`Constitutional Violation: ${verification.explanation}`)
    }

    // Mock Git push
    await new Promise(resolve => setTimeout(resolve, 1000))
  }

  async pull(remote: string, branch?: string): Promise<void> {
    // Mock Git pull
    await new Promise(resolve => setTimeout(resolve, 1000))
  }

  private generateCommitHash(): string {
    return Math.random().toString(36).substr(2, 40)
  }
}

// Export singleton instance
export const fileSystemService = new FileSystemService()