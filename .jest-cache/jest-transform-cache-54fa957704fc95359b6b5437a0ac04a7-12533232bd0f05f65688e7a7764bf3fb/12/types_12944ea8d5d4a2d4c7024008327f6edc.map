{"version":3,"names":["cov_k9q1akqae","actualCoverage","QueryComplexity","exports","RoutingTier"],"sources":["types.ts"],"sourcesContent":["/**\r\n * AI Routing System - Type Definitions\r\n * Interfaces for query classification, routing decisions, and metrics\r\n */\r\n\r\n/**\r\n * Query complexity levels for routing decisions\r\n */\r\nexport enum QueryComplexity {\r\n  SIMPLE = 'SIMPLE',\r\n  MODERATE = 'MODERATE',\r\n  COMPLEX = 'COMPLEX'\r\n}\r\n\r\n/**\r\n * Routing tiers for different processing strategies\r\n */\r\nexport enum RoutingTier {\r\n  LOCAL_LLM = 'LOCAL_LLM',      // Quantized Llama/Phi on-device\r\n  RAP_SYSTEM = 'RAP_SYSTEM',    // Retrieval-Augmented Prompt with Knowledge Ocean\r\n  EXTERNAL_LLM = 'EXTERNAL_LLM' // OpenAI GPT-4 or similar\r\n}\r\n\r\n/**\r\n * Incoming query from user\r\n */\r\nexport interface AIQuery {\r\n  id?: string;\r\n  query: string;\r\n  userId?: string;\r\n  context?: Record<string, any>;\r\n  metadata?: Record<string, any>;\r\n}\r\n\r\n/**\r\n * Query classification result\r\n */\r\nexport interface QueryClassificationResult {\r\n  id: string;\r\n  query: string;\r\n  classifiedAs: QueryComplexity;\r\n  confidence: number; // 0.0 to 1.0\r\n  routedTo: RoutingTier;\r\n  reasoning?: string;\r\n  metadata?: Record<string, any>;\r\n}\r\n\r\n/**\r\n * Routing decision with metrics\r\n */\r\nexport interface RoutingDecision {\r\n  tier: RoutingTier;\r\n  confidence: number;\r\n  estimatedCost: number;\r\n  estimatedLatency: number;\r\n  fallbackTier?: RoutingTier;\r\n  reason: string;\r\n}\r\n\r\n/**\r\n * AI response with routing metadata\r\n */\r\nexport interface AIResponse {\r\n  id: string;\r\n  content: string;\r\n  routingTier: RoutingTier;\r\n  responseTime: number; // milliseconds\r\n  cost: number;\r\n  cached: boolean;\r\n  metadata?: Record<string, any>;\r\n}\r\n\r\n/**\r\n * Routing metrics for a specific tier\r\n */\r\nexport interface RoutingMetricsData {\r\n  routingTier: RoutingTier;\r\n  totalRequests: number;\r\n  successfulRequests: number;\r\n  failedRequests: number;\r\n  averageResponseTime: number; // milliseconds\r\n  averageCost: number;\r\n  cacheHits: number;\r\n  cacheMisses: number;\r\n  cacheHitRate: number; // percentage\r\n  successRate: number; // percentage\r\n  lastUpdated: Date;\r\n}\r\n\r\n/**\r\n * Cache entry for routing decisions and responses\r\n */\r\nexport interface CacheEntry {\r\n  id: string;\r\n  queryHash: string;\r\n  query: string;\r\n  response: string;\r\n  routingTier: RoutingTier;\r\n  cost: number;\r\n  ttl: number; // seconds\r\n  expiresAt: Date;\r\n  hitCount: number;\r\n}\r\n\r\n/**\r\n * Query classifier interface\r\n */\r\nexport interface IQueryClassifier {\r\n  classify(query: AIQuery): Promise<QueryClassificationResult>;\r\n  getClassificationMetrics(): Promise<Record<QueryComplexity, number>>;\r\n}\r\n\r\n/**\r\n * Routing decision maker interface\r\n */\r\nexport interface IRoutingDecisionMaker {\r\n  makeDecision(classification: QueryClassificationResult): Promise<RoutingDecision>;\r\n  updateMetrics(tier: RoutingTier, success: boolean, responseTime: number, cost: number): Promise<void>;\r\n  getMetrics(tier: RoutingTier): Promise<RoutingMetricsData>;\r\n}\r\n\r\n/**\r\n * Cache manager interface\r\n */\r\nexport interface ICacheManager {\r\n  get(queryHash: string): Promise<CacheEntry | null>;\r\n  set(entry: CacheEntry): Promise<void>;\r\n  delete(queryHash: string): Promise<void>;\r\n  clear(): Promise<void>;\r\n  getStats(): Promise<{ hits: number; misses: number; size: number }>;\r\n}\r\n\r\n/**\r\n * Cost optimizer interface\r\n */\r\nexport interface ICostOptimizer {\r\n  calculateCost(tier: RoutingTier, inputTokens?: number, outputTokens?: number): Promise<number>;\r\n  trackSpending(userId: string, tier: RoutingTier, cost: number): Promise<void>;\r\n  getSpendingMetrics(): Promise<Record<RoutingTier, number>>;\r\n  shouldRejectQuery(tier: RoutingTier, cost: number, userBudget?: number): Promise<boolean>;\r\n  getCheapestTier(inputTokens?: number, outputTokens?: number): Promise<RoutingTier>;\r\n  getUserSpending(userId: string): Promise<any>;\r\n  compareCosts(inputTokens?: number, outputTokens?: number): Promise<Record<RoutingTier, number>>;\r\n  getTierSpending(tier: RoutingTier): Promise<any>;\r\n  getAverageCostPerQuery(tier: RoutingTier): Promise<number>;\r\n  getTotalCost(tier: RoutingTier): Promise<number>;\r\n  getTotalQueries(tier: RoutingTier): Promise<number>;\r\n  getTotalSpending(): Promise<number>;\r\n  resetTierMetrics(tier: RoutingTier): Promise<void>;\r\n}\r\n\r\n/**\r\n * Hierarchical router interface\r\n */\r\nexport interface IHierarchicalRouter {\r\n  route(query: AIQuery): Promise<AIResponse>;\r\n  classify(query: AIQuery): Promise<QueryClassificationResult>;\r\n  getMetrics(): Promise<Record<RoutingTier, RoutingMetricsData>>;\r\n}\r\n\r\n/**\r\n * Configuration for AI routing system\r\n */\r\nexport interface AIRoutingConfig {\r\n  // Local LLM settings\r\n  localLLMEnabled: boolean;\r\n  localLLMModel: string; // 'llama' or 'phi'\r\n  localLLMQuantization: string; // 'q4', 'q5', 'q8'\r\n  \r\n  // RAP system settings\r\n  rapEnabled: boolean;\r\n  knowledgeOceanUrl: string;\r\n  internalSourceWeight: number; // 0.7 for 70%\r\n  externalSourceWeight: number; // 0.3 for 30%\r\n  \r\n  // External LLM settings\r\n  externalLLMEnabled: boolean;\r\n  externalLLMProvider: string; // 'openai', 'anthropic'\r\n  externalLLMModel: string;\r\n  \r\n  // Cache settings\r\n  cacheEnabled: boolean;\r\n  cacheTTL: number; // seconds\r\n  cacheMaxSize: number; // entries\r\n  \r\n  // Cost settings\r\n  costTrackingEnabled: boolean;\r\n  costThreshold: number; // maximum cost per query\r\n  \r\n  // Latency settings\r\n  latencyThreshold: number; // milliseconds\r\n  fallbackOnLatency: boolean;\r\n  \r\n  // Redis settings\r\n  redisUrl: string;\r\n  redisKeyPrefix: string;\r\n}\r\n\r\n/**\r\n * Classification confidence thresholds\r\n */\r\nexport interface ClassificationThresholds {\r\n  simpleThreshold: number;      // queries below this are SIMPLE\r\n  moderateThreshold: number;    // queries below this are MODERATE\r\n  complexThreshold: number;     // queries at or above this are COMPLEX\r\n  minConfidence: number;        // minimum confidence to accept classification\r\n}\r\n\r\n/**\r\n * Fallback strategy configuration\r\n */\r\nexport interface FallbackStrategy {\r\n  tier: RoutingTier;\r\n  condition: 'latency' | 'cost' | 'failure' | 'all';\r\n  threshold: number;\r\n  nextTier: RoutingTier;\r\n}\r\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAeY;IAAAA,aAAA,YAAAA,CAAA;MAAA,OAAAC,cAAA;IAAA;EAAA;EAAA,OAAAA,cAAA;AAAA;AAAAD,aAAA;AAfZ;AACA;AACA;AACA;AAEA;AACA;AACA;AAFA,IAGYE,eAAe,GAAAC,OAAA,CAAAD,eAAA,0BAAfA,eAAe;EAAfA,eAAe;EAAfA,eAAe;EAAfA,eAAe;EAAA,OAAfA,eAAe;AAAA;AAM3B;AACA;AACA;AAFA;AAAA,IAGYE,WAAW,GAAAD,OAAA,CAAAC,WAAA,0BAAXA,WAAW;EAAXA,WAAW;EACS;EADpBA,WAAW;EAES;EAFpBA,WAAW,mCAGS;EAAA,OAHpBA,WAAW;AAAA;AAMvB;AACA;AACA;AASA;AACA;AACA;AAWA;AACA;AACA;AAUA;AACA;AACA;AAWA;AACA;AACA;AAeA;AACA;AACA;AAaA;AACA;AACA;AAMA;AACA;AACA;AAOA;AACA;AACA;AASA;AACA;AACA;AAiBA;AACA;AACA;AAOA;AACA;AACA;AAoCA;AACA;AACA;AAQA;AACA;AACA","ignoreList":[]}