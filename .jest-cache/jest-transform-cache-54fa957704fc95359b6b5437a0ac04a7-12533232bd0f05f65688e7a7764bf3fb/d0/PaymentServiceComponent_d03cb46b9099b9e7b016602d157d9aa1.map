{"version":3,"names":["path","_interopRequireWildcard","require","e","t","WeakMap","r","n","__esModule","o","i","f","__proto__","default","has","get","set","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","PaymentServiceComponent","generatePaymentService","config","outputDir","changes","serviceName","serviceDir","join","push","type","content","generateIndexFile","generatePaymentController","generateWebhookController","generateStripeService","generatePaymentServiceFile","enableSubscriptions","generateSubscriptionService","generatePaymentRepository","generateTypes","generateValidationSchemas","generatePrismaSchema","generatePackageJson","generateEnvExample","generateReadme","port","enableRefunds","stripeApiVersion","JSON","stringify","name","version","description","main","scripts","dev","build","start","test","dependencies","express","cors","helmet","zod","stripe","devDependencies","typescript","jest","prisma","webhookSecret","exports"],"sources":["PaymentServiceComponent.ts"],"sourcesContent":["import * as path from 'path';\nimport { FileChange } from '../ChangesetManager';\n\nexport interface PaymentServiceConfig {\n  name: string;\n  port?: number;\n  stripeApiVersion?: string;\n  enableSubscriptions?: boolean;\n  enableRefunds?: boolean;\n  webhookSecret?: string;\n}\n\nexport class PaymentServiceComponent {\n  /**\n   * Generate complete Stripe payment integration\n   */\n  generatePaymentService(config: PaymentServiceConfig, outputDir: string): FileChange[] {\n    const changes: FileChange[] = [];\n    const serviceName = 'payment-service';\n    const serviceDir = path.join(outputDir, 'services', serviceName);\n\n    // Main service file\n    changes.push({\n      path: path.join(serviceDir, 'src', 'index.ts'),\n      type: 'create',\n      content: this.generateIndexFile(config),\n    });\n\n    // Controllers\n    changes.push({\n      path: path.join(serviceDir, 'src', 'controllers', 'payment.controller.ts'),\n      type: 'create',\n      content: this.generatePaymentController(config),\n    });\n\n    changes.push({\n      path: path.join(serviceDir, 'src', 'controllers', 'webhook.controller.ts'),\n      type: 'create',\n      content: this.generateWebhookController(config),\n    });\n\n    // Services\n    changes.push({\n      path: path.join(serviceDir, 'src', 'services', 'stripe.service.ts'),\n      type: 'create',\n      content: this.generateStripeService(config),\n    });\n\n    changes.push({\n      path: path.join(serviceDir, 'src', 'services', 'payment.service.ts'),\n      type: 'create',\n      content: this.generatePaymentServiceFile(config),\n    });\n\n    if (config.enableSubscriptions) {\n      changes.push({\n        path: path.join(serviceDir, 'src', 'services', 'subscription.service.ts'),\n        type: 'create',\n        content: this.generateSubscriptionService(),\n      });\n    }\n\n    // Repository\n    changes.push({\n      path: path.join(serviceDir, 'src', 'repositories', 'payment.repository.ts'),\n      type: 'create',\n      content: this.generatePaymentRepository(),\n    });\n\n    // Types\n    changes.push({\n      path: path.join(serviceDir, 'src', 'types', 'index.ts'),\n      type: 'create',\n      content: this.generateTypes(config),\n    });\n\n    // Validation schemas\n    changes.push({\n      path: path.join(serviceDir, 'src', 'validation', 'payment.schemas.ts'),\n      type: 'create',\n      content: this.generateValidationSchemas(config),\n    });\n\n    // Prisma schema\n    changes.push({\n      path: path.join(serviceDir, 'prisma', 'schema.prisma'),\n      type: 'create',\n      content: this.generatePrismaSchema(config),\n    });\n\n    // Configuration files\n    changes.push({\n      path: path.join(serviceDir, 'package.json'),\n      type: 'create',\n      content: this.generatePackageJson(config),\n    });\n\n    changes.push({\n      path: path.join(serviceDir, '.env.example'),\n      type: 'create',\n      content: this.generateEnvExample(config),\n    });\n\n    changes.push({\n      path: path.join(serviceDir, 'README.md'),\n      type: 'create',\n      content: this.generateReadme(config),\n    });\n\n    return changes;\n  }\n\n  private generateIndexFile(config: PaymentServiceConfig): string {\n    const port = config.port || 3002;\n    return `import express, { Application } from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport { PaymentController } from './controllers/payment.controller';\nimport { WebhookController } from './controllers/webhook.controller';\nimport { errorHandler } from './middleware/error-handler';\n\nconst app: Application = express();\nconst PORT = process.env.PORT || ${port};\n\n// Middleware\napp.use(helmet());\napp.use(cors());\n\n// Webhook endpoint needs raw body\napp.use('/api/webhooks', express.raw({ type: 'application/json' }));\n\n// JSON parsing for other routes\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\n// Health check\napp.get('/health', (req, res) => {\n  res.json({ status: 'healthy', service: 'payment-service' });\n});\n\n// Routes\nconst paymentController = new PaymentController();\nconst webhookController = new WebhookController();\n\napp.use('/api/payments', paymentController.router);\napp.use('/api/webhooks', webhookController.router);\n\n// Error handling\napp.use(errorHandler);\n\n// Start server\napp.listen(PORT, () => {\n  console.log(\\`Payment service running on port \\${PORT}\\`);\n});\n\nexport default app;\n`;\n  }\n\n  private generatePaymentController(config: PaymentServiceConfig): string {\n    return `import { Router, Request, Response, NextFunction } from 'express';\nimport { PaymentService } from '../services/payment.service';\n${config.enableSubscriptions ? \"import { SubscriptionService } from '../services/subscription.service';\" : ''}\nimport { validate } from '../middleware/validation';\nimport { PaymentSchemas } from '../validation/payment.schemas';\nimport { authMiddleware } from '../middleware/auth.middleware';\n\nexport class PaymentController {\n  public router: Router;\n  private paymentService: PaymentService;\n${config.enableSubscriptions ? '  private subscriptionService: SubscriptionService;' : ''}\n\n  constructor() {\n    this.router = Router();\n    this.paymentService = new PaymentService();\n${config.enableSubscriptions ? '    this.subscriptionService = new SubscriptionService();' : ''}\n    this.initializeRoutes();\n  }\n\n  private initializeRoutes(): void {\n    // Create payment intent\n    this.router.post(\n      '/intent',\n      authMiddleware,\n      validate(PaymentSchemas.createIntent),\n      this.createPaymentIntent.bind(this)\n    );\n    \n    // Confirm payment\n    this.router.post(\n      '/confirm',\n      authMiddleware,\n      validate(PaymentSchemas.confirmPayment),\n      this.confirmPayment.bind(this)\n    );\n    \n    // Get payment by ID\n    this.router.get('/:id', authMiddleware, this.getPayment.bind(this));\n    \n    // List user payments\n    this.router.get('/', authMiddleware, this.listPayments.bind(this));\n${config.enableRefunds ? `\n    // Refund payment\n    this.router.post(\n      '/:id/refund',\n      authMiddleware,\n      validate(PaymentSchemas.refund),\n      this.refundPayment.bind(this)\n    );\n` : ''}${config.enableSubscriptions ? `\n    // Subscription endpoints\n    this.router.post(\n      '/subscriptions',\n      authMiddleware,\n      validate(PaymentSchemas.createSubscription),\n      this.createSubscription.bind(this)\n    );\n    \n    this.router.get('/subscriptions', authMiddleware, this.listSubscriptions.bind(this));\n    \n    this.router.post(\n      '/subscriptions/:id/cancel',\n      authMiddleware,\n      this.cancelSubscription.bind(this)\n    );\n` : ''}\n  }\n\n  private async createPaymentIntent(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const result = await this.paymentService.createPaymentIntent({\n        ...req.body,\n        userId: req.user!.userId,\n      });\n      res.json({ success: true, data: result });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  private async confirmPayment(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const result = await this.paymentService.confirmPayment(req.body.paymentIntentId);\n      res.json({ success: true, data: result });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  private async getPayment(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const payment = await this.paymentService.getPayment(req.params.id, req.user!.userId);\n      res.json({ success: true, data: payment });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  private async listPayments(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const payments = await this.paymentService.listUserPayments(req.user!.userId);\n      res.json({ success: true, data: payments });\n    } catch (error) {\n      next(error);\n    }\n  }\n${config.enableRefunds ? `\n  private async refundPayment(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const result = await this.paymentService.refundPayment(\n        req.params.id,\n        req.user!.userId,\n        req.body.amount,\n        req.body.reason\n      );\n      res.json({ success: true, data: result });\n    } catch (error) {\n      next(error);\n    }\n  }\n` : ''}${config.enableSubscriptions ? `\n  private async createSubscription(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const result = await this.subscriptionService.createSubscription({\n        ...req.body,\n        userId: req.user!.userId,\n      });\n      res.json({ success: true, data: result });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  private async listSubscriptions(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const subscriptions = await this.subscriptionService.listUserSubscriptions(req.user!.userId);\n      res.json({ success: true, data: subscriptions });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  private async cancelSubscription(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      await this.subscriptionService.cancelSubscription(req.params.id, req.user!.userId);\n      res.json({ success: true, message: 'Subscription cancelled' });\n    } catch (error) {\n      next(error);\n    }\n  }\n` : ''}\n}\n`;\n  }\n\n  private generateWebhookController(config: PaymentServiceConfig): string {\n    return `import { Router, Request, Response, NextFunction } from 'express';\nimport { StripeService } from '../services/stripe.service';\nimport { PaymentService } from '../services/payment.service';\n\nexport class WebhookController {\n  public router: Router;\n  private stripeService: StripeService;\n  private paymentService: PaymentService;\n\n  constructor() {\n    this.router = Router();\n    this.stripeService = new StripeService();\n    this.paymentService = new PaymentService();\n    this.initializeRoutes();\n  }\n\n  private initializeRoutes(): void {\n    this.router.post('/stripe', this.handleStripeWebhook.bind(this));\n  }\n\n  private async handleStripeWebhook(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const signature = req.headers['stripe-signature'] as string;\n      const event = this.stripeService.constructWebhookEvent(req.body, signature);\n\n      // Handle different event types\n      switch (event.type) {\n        case 'payment_intent.succeeded':\n          await this.paymentService.handlePaymentSuccess(event.data.object);\n          break;\n        \n        case 'payment_intent.payment_failed':\n          await this.paymentService.handlePaymentFailure(event.data.object);\n          break;\n${config.enableSubscriptions ? `\n        case 'customer.subscription.created':\n          await this.paymentService.handleSubscriptionCreated(event.data.object);\n          break;\n        \n        case 'customer.subscription.updated':\n          await this.paymentService.handleSubscriptionUpdated(event.data.object);\n          break;\n        \n        case 'customer.subscription.deleted':\n          await this.paymentService.handleSubscriptionCancelled(event.data.object);\n          break;\n        \n        case 'invoice.payment_succeeded':\n          await this.paymentService.handleInvoicePaymentSucceeded(event.data.object);\n          break;\n        \n        case 'invoice.payment_failed':\n          await this.paymentService.handleInvoicePaymentFailed(event.data.object);\n          break;\n` : ''}${config.enableRefunds ? `\n        case 'charge.refunded':\n          await this.paymentService.handleRefund(event.data.object);\n          break;\n` : ''}\n        default:\n          console.log(\\`Unhandled event type: \\${event.type}\\`);\n      }\n\n      res.json({ received: true });\n    } catch (error) {\n      next(error);\n    }\n  }\n}\n`;\n  }\n\n  private generateStripeService(config: PaymentServiceConfig): string {\n    return `import Stripe from 'stripe';\nimport { AppError } from '../middleware/error-handler';\n\nexport class StripeService {\n  private stripe: Stripe;\n  private webhookSecret: string;\n\n  constructor() {\n    const apiKey = process.env.STRIPE_SECRET_KEY;\n    if (!apiKey) {\n      throw new Error('STRIPE_SECRET_KEY is required');\n    }\n\n    this.stripe = new Stripe(apiKey, {\n      apiVersion: '${config.stripeApiVersion || '2023-10-16'}',\n    });\n\n    this.webhookSecret = process.env.STRIPE_WEBHOOK_SECRET || '';\n  }\n\n  async createPaymentIntent(amount: number, currency: string, metadata?: Record<string, string>): Promise<Stripe.PaymentIntent> {\n    return this.stripe.paymentIntents.create({\n      amount,\n      currency,\n      metadata,\n    });\n  }\n\n  async confirmPaymentIntent(paymentIntentId: string): Promise<Stripe.PaymentIntent> {\n    return this.stripe.paymentIntents.confirm(paymentIntentId);\n  }\n\n  async retrievePaymentIntent(paymentIntentId: string): Promise<Stripe.PaymentIntent> {\n    return this.stripe.paymentIntents.retrieve(paymentIntentId);\n  }\n${config.enableRefunds ? `\n  async createRefund(paymentIntentId: string, amount?: number, reason?: string): Promise<Stripe.Refund> {\n    return this.stripe.refunds.create({\n      payment_intent: paymentIntentId,\n      amount,\n      reason: reason as Stripe.RefundCreateParams.Reason,\n    });\n  }\n` : ''}${config.enableSubscriptions ? `\n  async createCustomer(email: string, name?: string, metadata?: Record<string, string>): Promise<Stripe.Customer> {\n    return this.stripe.customers.create({\n      email,\n      name,\n      metadata,\n    });\n  }\n\n  async createSubscription(customerId: string, priceId: string, metadata?: Record<string, string>): Promise<Stripe.Subscription> {\n    return this.stripe.subscriptions.create({\n      customer: customerId,\n      items: [{ price: priceId }],\n      metadata,\n    });\n  }\n\n  async cancelSubscription(subscriptionId: string): Promise<Stripe.Subscription> {\n    return this.stripe.subscriptions.cancel(subscriptionId);\n  }\n\n  async retrieveSubscription(subscriptionId: string): Promise<Stripe.Subscription> {\n    return this.stripe.subscriptions.retrieve(subscriptionId);\n  }\n` : ''}\n  constructWebhookEvent(payload: Buffer, signature: string): Stripe.Event {\n    try {\n      return this.stripe.webhooks.constructEvent(payload, signature, this.webhookSecret);\n    } catch (error) {\n      throw new AppError(400, 'Invalid webhook signature');\n    }\n  }\n}\n`;\n  }\n\n  private generatePaymentServiceFile(config: PaymentServiceConfig): string {\n    return `import { StripeService } from './stripe.service';\nimport { PaymentRepository } from '../repositories/payment.repository';\nimport { AppError } from '../middleware/error-handler';\nimport { Payment, PaymentStatus, CreatePaymentIntentInput } from '../types';\n\nexport class PaymentService {\n  private stripeService: StripeService;\n  private paymentRepository: PaymentRepository;\n\n  constructor() {\n    this.stripeService = new StripeService();\n    this.paymentRepository = new PaymentRepository();\n  }\n\n  async createPaymentIntent(input: CreatePaymentIntentInput): Promise<Payment> {\n    const paymentIntent = await this.stripeService.createPaymentIntent(\n      input.amount,\n      input.currency || 'usd',\n      {\n        userId: input.userId,\n        ...input.metadata,\n      }\n    );\n\n    const payment = await this.paymentRepository.create({\n      userId: input.userId,\n      stripePaymentIntentId: paymentIntent.id,\n      amount: input.amount,\n      currency: input.currency || 'usd',\n      status: 'pending',\n      metadata: input.metadata,\n    });\n\n    return payment;\n  }\n\n  async confirmPayment(paymentIntentId: string): Promise<Payment> {\n    const paymentIntent = await this.stripeService.confirmPaymentIntent(paymentIntentId);\n    \n    const payment = await this.paymentRepository.findByStripePaymentIntentId(paymentIntentId);\n    if (!payment) {\n      throw new AppError(404, 'Payment not found');\n    }\n\n    return this.paymentRepository.update(payment.id, {\n      status: paymentIntent.status as PaymentStatus,\n    });\n  }\n\n  async getPayment(paymentId: string, userId: string): Promise<Payment> {\n    const payment = await this.paymentRepository.findById(paymentId);\n    \n    if (!payment) {\n      throw new AppError(404, 'Payment not found');\n    }\n\n    if (payment.userId !== userId) {\n      throw new AppError(403, 'Access denied');\n    }\n\n    return payment;\n  }\n\n  async listUserPayments(userId: string): Promise<Payment[]> {\n    return this.paymentRepository.findByUserId(userId);\n  }\n${config.enableRefunds ? `\n  async refundPayment(paymentId: string, userId: string, amount?: number, reason?: string): Promise<Payment> {\n    const payment = await this.getPayment(paymentId, userId);\n\n    if (payment.status !== 'succeeded') {\n      throw new AppError(400, 'Can only refund successful payments');\n    }\n\n    await this.stripeService.createRefund(payment.stripePaymentIntentId, amount, reason);\n\n    return this.paymentRepository.update(payment.id, {\n      status: 'refunded',\n    });\n  }\n` : ''}\n  async handlePaymentSuccess(paymentIntent: any): Promise<void> {\n    const payment = await this.paymentRepository.findByStripePaymentIntentId(paymentIntent.id);\n    if (payment) {\n      await this.paymentRepository.update(payment.id, {\n        status: 'succeeded',\n      });\n    }\n  }\n\n  async handlePaymentFailure(paymentIntent: any): Promise<void> {\n    const payment = await this.paymentRepository.findByStripePaymentIntentId(paymentIntent.id);\n    if (payment) {\n      await this.paymentRepository.update(payment.id, {\n        status: 'failed',\n      });\n    }\n  }\n${config.enableSubscriptions ? `\n  async handleSubscriptionCreated(subscription: any): Promise<void> {\n    // Handle subscription creation\n    console.log('Subscription created:', subscription.id);\n  }\n\n  async handleSubscriptionUpdated(subscription: any): Promise<void> {\n    // Handle subscription update\n    console.log('Subscription updated:', subscription.id);\n  }\n\n  async handleSubscriptionCancelled(subscription: any): Promise<void> {\n    // Handle subscription cancellation\n    console.log('Subscription cancelled:', subscription.id);\n  }\n\n  async handleInvoicePaymentSucceeded(invoice: any): Promise<void> {\n    // Handle successful invoice payment\n    console.log('Invoice payment succeeded:', invoice.id);\n  }\n\n  async handleInvoicePaymentFailed(invoice: any): Promise<void> {\n    // Handle failed invoice payment\n    console.log('Invoice payment failed:', invoice.id);\n  }\n` : ''}${config.enableRefunds ? `\n  async handleRefund(charge: any): Promise<void> {\n    // Handle refund\n    console.log('Refund processed:', charge.id);\n  }\n` : ''}\n}\n`;\n  }\n\n  private generateSubscriptionService(): string {\n    return `import { StripeService } from './stripe.service';\nimport { PaymentRepository } from '../repositories/payment.repository';\nimport { AppError } from '../middleware/error-handler';\nimport { Subscription, CreateSubscriptionInput } from '../types';\n\nexport class SubscriptionService {\n  private stripeService: StripeService;\n  private paymentRepository: PaymentRepository;\n\n  constructor() {\n    this.stripeService = new StripeService();\n    this.paymentRepository = new PaymentRepository();\n  }\n\n  async createSubscription(input: CreateSubscriptionInput): Promise<Subscription> {\n    // Create or get Stripe customer\n    let customer = await this.paymentRepository.findCustomerByUserId(input.userId);\n    \n    if (!customer) {\n      const stripeCustomer = await this.stripeService.createCustomer(\n        input.email,\n        input.name,\n        { userId: input.userId }\n      );\n      customer = await this.paymentRepository.createCustomer({\n        userId: input.userId,\n        stripeCustomerId: stripeCustomer.id,\n        email: input.email,\n      });\n    }\n\n    // Create subscription\n    const stripeSubscription = await this.stripeService.createSubscription(\n      customer.stripeCustomerId,\n      input.priceId,\n      input.metadata\n    );\n\n    const subscription = await this.paymentRepository.createSubscription({\n      userId: input.userId,\n      stripeSubscriptionId: stripeSubscription.id,\n      priceId: input.priceId,\n      status: stripeSubscription.status,\n      currentPeriodStart: new Date(stripeSubscription.current_period_start * 1000),\n      currentPeriodEnd: new Date(stripeSubscription.current_period_end * 1000),\n    });\n\n    return subscription;\n  }\n\n  async listUserSubscriptions(userId: string): Promise<Subscription[]> {\n    return this.paymentRepository.findSubscriptionsByUserId(userId);\n  }\n\n  async cancelSubscription(subscriptionId: string, userId: string): Promise<void> {\n    const subscription = await this.paymentRepository.findSubscriptionById(subscriptionId);\n    \n    if (!subscription) {\n      throw new AppError(404, 'Subscription not found');\n    }\n\n    if (subscription.userId !== userId) {\n      throw new AppError(403, 'Access denied');\n    }\n\n    await this.stripeService.cancelSubscription(subscription.stripeSubscriptionId);\n\n    await this.paymentRepository.updateSubscription(subscriptionId, {\n      status: 'canceled',\n    });\n  }\n}\n`;\n  }\n\n  private generatePaymentRepository(): string {\n    return `import { PrismaClient } from '@prisma/client';\nimport { Payment, CreatePaymentInput, UpdatePaymentInput, Customer, Subscription } from '../types';\n\nconst prisma = new PrismaClient();\n\nexport class PaymentRepository {\n  async create(data: CreatePaymentInput): Promise<Payment> {\n    return prisma.payment.create({ data });\n  }\n\n  async findById(id: string): Promise<Payment | null> {\n    return prisma.payment.findUnique({ where: { id } });\n  }\n\n  async findByStripePaymentIntentId(stripePaymentIntentId: string): Promise<Payment | null> {\n    return prisma.payment.findUnique({ where: { stripePaymentIntentId } });\n  }\n\n  async findByUserId(userId: string): Promise<Payment[]> {\n    return prisma.payment.findMany({\n      where: { userId },\n      orderBy: { createdAt: 'desc' },\n    });\n  }\n\n  async update(id: string, data: UpdatePaymentInput): Promise<Payment> {\n    return prisma.payment.update({\n      where: { id },\n      data,\n    });\n  }\n\n  async findCustomerByUserId(userId: string): Promise<Customer | null> {\n    return prisma.customer.findUnique({ where: { userId } });\n  }\n\n  async createCustomer(data: { userId: string; stripeCustomerId: string; email: string }): Promise<Customer> {\n    return prisma.customer.create({ data });\n  }\n\n  async createSubscription(data: any): Promise<Subscription> {\n    return prisma.subscription.create({ data });\n  }\n\n  async findSubscriptionById(id: string): Promise<Subscription | null> {\n    return prisma.subscription.findUnique({ where: { id } });\n  }\n\n  async findSubscriptionsByUserId(userId: string): Promise<Subscription[]> {\n    return prisma.subscription.findMany({\n      where: { userId },\n      orderBy: { createdAt: 'desc' },\n    });\n  }\n\n  async updateSubscription(id: string, data: any): Promise<Subscription> {\n    return prisma.subscription.update({\n      where: { id },\n      data,\n    });\n  }\n}\n`;\n  }\n\n  private generateTypes(config: PaymentServiceConfig): string {\n    return `export type PaymentStatus = 'pending' | 'succeeded' | 'failed' | 'refunded' | 'canceled';\n\nexport interface Payment {\n  id: string;\n  userId: string;\n  stripePaymentIntentId: string;\n  amount: number;\n  currency: string;\n  status: PaymentStatus;\n  metadata?: Record<string, any>;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface CreatePaymentInput {\n  userId: string;\n  stripePaymentIntentId: string;\n  amount: number;\n  currency: string;\n  status: PaymentStatus;\n  metadata?: Record<string, any>;\n}\n\nexport interface UpdatePaymentInput {\n  status?: PaymentStatus;\n  metadata?: Record<string, any>;\n}\n\nexport interface CreatePaymentIntentInput {\n  userId: string;\n  amount: number;\n  currency?: string;\n  metadata?: Record<string, any>;\n}\n${config.enableSubscriptions ? `\nexport interface Customer {\n  id: string;\n  userId: string;\n  stripeCustomerId: string;\n  email: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface Subscription {\n  id: string;\n  userId: string;\n  stripeSubscriptionId: string;\n  priceId: string;\n  status: string;\n  currentPeriodStart: Date;\n  currentPeriodEnd: Date;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface CreateSubscriptionInput {\n  userId: string;\n  email: string;\n  name?: string;\n  priceId: string;\n  metadata?: Record<string, any>;\n}\n` : ''}\n`;\n  }\n\n  private generateValidationSchemas(config: PaymentServiceConfig): string {\n    return `import { z } from 'zod';\n\nexport const PaymentSchemas = {\n  createIntent: z.object({\n    body: z.object({\n      amount: z.number().positive('Amount must be positive'),\n      currency: z.string().length(3).optional(),\n      metadata: z.record(z.string()).optional(),\n    }),\n  }),\n\n  confirmPayment: z.object({\n    body: z.object({\n      paymentIntentId: z.string().min(1, 'Payment intent ID is required'),\n    }),\n  }),\n${config.enableRefunds ? `\n  refund: z.object({\n    body: z.object({\n      amount: z.number().positive().optional(),\n      reason: z.enum(['duplicate', 'fraudulent', 'requested_by_customer']).optional(),\n    }),\n  }),\n` : ''}${config.enableSubscriptions ? `\n  createSubscription: z.object({\n    body: z.object({\n      email: z.string().email('Invalid email address'),\n      name: z.string().optional(),\n      priceId: z.string().min(1, 'Price ID is required'),\n      metadata: z.record(z.string()).optional(),\n    }),\n  }),\n` : ''}\n};\n`;\n  }\n\n  private generatePrismaSchema(config: PaymentServiceConfig): string {\n    return `generator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel Payment {\n  id                    String   @id @default(cuid())\n  userId                String\n  stripePaymentIntentId String   @unique\n  amount                Int\n  currency              String\n  status                String\n  metadata              Json?\n  createdAt             DateTime @default(now())\n  updatedAt             DateTime @updatedAt\n  \n  @@index([userId])\n  @@index([status])\n  @@map(\"payments\")\n}\n${config.enableSubscriptions ? `\nmodel Customer {\n  id               String   @id @default(cuid())\n  userId           String   @unique\n  stripeCustomerId String   @unique\n  email            String\n  createdAt        DateTime @default(now())\n  updatedAt        DateTime @updatedAt\n  \n  @@map(\"customers\")\n}\n\nmodel Subscription {\n  id                   String   @id @default(cuid())\n  userId               String\n  stripeSubscriptionId String   @unique\n  priceId              String\n  status               String\n  currentPeriodStart   DateTime\n  currentPeriodEnd     DateTime\n  createdAt            DateTime @default(now())\n  updatedAt            DateTime @updatedAt\n  \n  @@index([userId])\n  @@index([status])\n  @@map(\"subscriptions\")\n}\n` : ''}\n`;\n  }\n\n  private generatePackageJson(config: PaymentServiceConfig): string {\n    return JSON.stringify({\n      name: 'payment-service',\n      version: '1.0.0',\n      description: 'Stripe Payment Integration Service',\n      main: 'dist/index.js',\n      scripts: {\n        dev: 'ts-node-dev --respawn --transpile-only src/index.ts',\n        build: 'tsc',\n        start: 'node dist/index.js',\n        test: 'jest',\n        'test:watch': 'jest --watch',\n        'prisma:generate': 'prisma generate',\n        'prisma:migrate': 'prisma migrate dev',\n      },\n      dependencies: {\n        express: '^4.18.2',\n        cors: '^2.8.5',\n        helmet: '^7.1.0',\n        zod: '^3.22.4',\n        '@prisma/client': '^5.7.1',\n        stripe: '^14.10.0',\n      },\n      devDependencies: {\n        '@types/express': '^4.17.21',\n        '@types/cors': '^2.8.17',\n        '@types/node': '^20.10.5',\n        typescript: '^5.3.3',\n        'ts-node-dev': '^2.0.0',\n        jest: '^29.7.0',\n        '@types/jest': '^29.5.11',\n        'ts-jest': '^29.1.1',\n        prisma: '^5.7.1',\n      },\n    }, null, 2);\n  }\n\n  private generateEnvExample(config: PaymentServiceConfig): string {\n    return `PORT=${config.port || 3002}\nNODE_ENV=development\n\nDATABASE_URL=postgresql://user:password@localhost:5432/payment_db\n\nSTRIPE_SECRET_KEY=sk_test_your_stripe_secret_key\nSTRIPE_WEBHOOK_SECRET=${config.webhookSecret || 'whsec_your_webhook_secret'}\n`;\n  }\n\n  private generateReadme(config: PaymentServiceConfig): string {\n    return `# Payment Service\n\nStripe payment integration service with payment processing${config.enableSubscriptions ? ', subscription billing' : ''}${config.enableRefunds ? ', and refund functionality' : ''}.\n\n## Features\n\n- Payment intent creation and confirmation\n- Webhook handling for payment events\n${config.enableSubscriptions ? '- Subscription management\\n' : ''}${config.enableRefunds ? '- Refund processing\\n' : ''}- Secure payment tracking\n\n## Installation\n\n\\`\\`\\`bash\nnpm install\n\\`\\`\\`\n\n## Database Setup\n\n\\`\\`\\`bash\nnpx prisma migrate dev\nnpx prisma generate\n\\`\\`\\`\n\n## Configuration\n\nCopy \\`.env.example\\` to \\`.env\\` and configure:\n\n- \\`STRIPE_SECRET_KEY\\`: Your Stripe secret key\n- \\`STRIPE_WEBHOOK_SECRET\\`: Your Stripe webhook secret\n- \\`DATABASE_URL\\`: PostgreSQL connection string\n\n## Development\n\n\\`\\`\\`bash\nnpm run dev\n\\`\\`\\`\n\n## Production\n\n\\`\\`\\`bash\nnpm run build\nnpm start\n\\`\\`\\`\n\n## API Endpoints\n\n### Payments\n- \\`POST /api/payments/intent\\` - Create payment intent\n- \\`POST /api/payments/confirm\\` - Confirm payment\n- \\`GET /api/payments/:id\\` - Get payment by ID\n- \\`GET /api/payments\\` - List user payments\n${config.enableRefunds ? '- `POST /api/payments/:id/refund` - Refund payment\\n' : ''}\n${config.enableSubscriptions ? `### Subscriptions\n- \\`POST /api/payments/subscriptions\\` - Create subscription\n- \\`GET /api/payments/subscriptions\\` - List user subscriptions\n- \\`POST /api/payments/subscriptions/:id/cancel\\` - Cancel subscription\n\n` : ''}### Webhooks\n- \\`POST /api/webhooks/stripe\\` - Stripe webhook endpoint\n\n## Testing\n\n\\`\\`\\`bash\nnpm test\n\\`\\`\\`\n\n## Stripe Webhook Setup\n\n1. Install Stripe CLI: https://stripe.com/docs/stripe-cli\n2. Forward webhooks to local server:\n   \\`\\`\\`bash\n   stripe listen --forward-to localhost:${config.port || 3002}/api/webhooks/stripe\n   \\`\\`\\`\n3. Copy the webhook signing secret to your \\`.env\\` file\n`;\n  }\n}\n"],"mappings":"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;IAC9D,MAAMuB,IAAI,GAAGvB,MAAM,CAACuB,IAAI,IAAI,IAAI;IAChC,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmCA,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;EACC;EAEQb,yBAAyBA,CAACV,MAA4B,EAAU;IACtE,OAAO;AACX;AACA,EAAEA,MAAM,CAACc,mBAAmB,GAAG,yEAAyE,GAAG,EAAE;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAEd,MAAM,CAACc,mBAAmB,GAAG,qDAAqD,GAAG,EAAE;AACzF;AACA;AACA;AACA;AACA,EAAEd,MAAM,CAACc,mBAAmB,GAAG,2DAA2D,GAAG,EAAE;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAEd,MAAM,CAACwB,aAAa,GAAG;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,EAAE,GAAGxB,MAAM,CAACc,mBAAmB,GAAG;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,EAAE;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAEd,MAAM,CAACwB,aAAa,GAAG;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,EAAE,GAAGxB,MAAM,CAACc,mBAAmB,GAAG;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,EAAE;AACN;AACA,CAAC;EACC;EAEQH,yBAAyBA,CAACX,MAA4B,EAAU;IACtE,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAEA,MAAM,CAACc,mBAAmB,GAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,EAAE,GAAGd,MAAM,CAACwB,aAAa,GAAG;AAChC;AACA;AACA;AACA,CAAC,GAAG,EAAE;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;EACC;EAEQZ,qBAAqBA,CAACZ,MAA4B,EAAU;IAClE,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqBA,MAAM,CAACyB,gBAAgB,IAAI,YAAY;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAEzB,MAAM,CAACwB,aAAa,GAAG;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,EAAE,GAAGxB,MAAM,CAACc,mBAAmB,GAAG;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,EAAE;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;EACC;EAEQD,0BAA0BA,CAACb,MAA4B,EAAU;IACvE,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAEA,MAAM,CAACwB,aAAa,GAAG;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,EAAE;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAExB,MAAM,CAACc,mBAAmB,GAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,EAAE,GAAGd,MAAM,CAACwB,aAAa,GAAG;AAChC;AACA;AACA;AACA;AACA,CAAC,GAAG,EAAE;AACN;AACA,CAAC;EACC;EAEQT,2BAA2BA,CAAA,EAAW;IAC5C,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;EACC;EAEQC,yBAAyBA,CAAA,EAAW;IAC1C,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;EACC;EAEQC,aAAaA,CAACjB,MAA4B,EAAU;IAC1D,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAEA,MAAM,CAACc,mBAAmB,GAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,EAAE;AACN,CAAC;EACC;EAEQI,yBAAyBA,CAAClB,MAA4B,EAAU;IACtE,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAEA,MAAM,CAACwB,aAAa,GAAG;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,EAAE,GAAGxB,MAAM,CAACc,mBAAmB,GAAG;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,EAAE;AACN;AACA,CAAC;EACC;EAEQK,oBAAoBA,CAACnB,MAA4B,EAAU;IACjE,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAEA,MAAM,CAACc,mBAAmB,GAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,EAAE;AACN,CAAC;EACC;EAEQM,mBAAmBA,CAACpB,MAA4B,EAAU;IAChE,OAAO0B,IAAI,CAACC,SAAS,CAAC;MACpBC,IAAI,EAAE,iBAAiB;MACvBC,OAAO,EAAE,OAAO;MAChBC,WAAW,EAAE,oCAAoC;MACjDC,IAAI,EAAE,eAAe;MACrBC,OAAO,EAAE;QACPC,GAAG,EAAE,qDAAqD;QAC1DC,KAAK,EAAE,KAAK;QACZC,KAAK,EAAE,oBAAoB;QAC3BC,IAAI,EAAE,MAAM;QACZ,YAAY,EAAE,cAAc;QAC5B,iBAAiB,EAAE,iBAAiB;QACpC,gBAAgB,EAAE;MACpB,CAAC;MACDC,YAAY,EAAE;QACZC,OAAO,EAAE,SAAS;QAClBC,IAAI,EAAE,QAAQ;QACdC,MAAM,EAAE,QAAQ;QAChBC,GAAG,EAAE,SAAS;QACd,gBAAgB,EAAE,QAAQ;QAC1BC,MAAM,EAAE;MACV,CAAC;MACDC,eAAe,EAAE;QACf,gBAAgB,EAAE,UAAU;QAC5B,aAAa,EAAE,SAAS;QACxB,aAAa,EAAE,UAAU;QACzBC,UAAU,EAAE,QAAQ;QACpB,aAAa,EAAE,QAAQ;QACvBC,IAAI,EAAE,SAAS;QACf,aAAa,EAAE,UAAU;QACzB,SAAS,EAAE,SAAS;QACpBC,MAAM,EAAE;MACV;IACF,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC;EACb;EAEQzB,kBAAkBA,CAACrB,MAA4B,EAAU;IAC/D,OAAO,QAAQA,MAAM,CAACuB,IAAI,IAAI,IAAI;AACtC;AACA;AACA;AACA;AACA;AACA,wBAAwBvB,MAAM,CAAC+C,aAAa,IAAI,2BAA2B;AAC3E,CAAC;EACC;EAEQzB,cAAcA,CAACtB,MAA4B,EAAU;IAC3D,OAAO;AACX;AACA,4DAA4DA,MAAM,CAACc,mBAAmB,GAAG,wBAAwB,GAAG,EAAE,GAAGd,MAAM,CAACwB,aAAa,GAAG,4BAA4B,GAAG,EAAE;AACjL;AACA;AACA;AACA;AACA;AACA,EAAExB,MAAM,CAACc,mBAAmB,GAAG,6BAA6B,GAAG,EAAE,GAAGd,MAAM,CAACwB,aAAa,GAAG,uBAAuB,GAAG,EAAE;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAExB,MAAM,CAACwB,aAAa,GAAG,sDAAsD,GAAG,EAAE;AACpF,EAAExB,MAAM,CAACc,mBAAmB,GAAG;AAC/B;AACA;AACA;AACA;AACA,CAAC,GAAG,EAAE;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0Cd,MAAM,CAACuB,IAAI,IAAI,IAAI;AAC7D;AACA;AACA,CAAC;EACC;AACF;AAACyB,OAAA,CAAAlD,uBAAA,GAAAA,uBAAA","ignoreList":[]}