{"version":3,"names":["parser","_interopRequireWildcard","require","_traverse","_interopRequireDefault","_generator","t","fs","e","__esModule","default","WeakMap","r","n","o","i","f","__proto__","has","get","set","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","CodeExecutor","parseCode","code","filePath","isTypeScript","endsWith","isJSX","parse","sourceType","plugins","filter","Boolean","generateCode","ast","output","generate","retainLines","compact","concise","comments","applyTransform","transform","promises","readFile","type","applyRenameTransform","options","applyExtractTransform","applyMoveTransform","applyUpdateImportsTransform","transformedCode","diagnostics","validateSyntax","success","d","severity","length","error","message","oldName","newName","traverse","Identifier","nodePath","node","name","binding","scope","getBinding","isIdentifier","path","referencePaths","forEach","refPath","startLine","endLine","functionName","Program","statements","extractedStatements","body","statement","loc","start","line","end","push","newFunction","functionDeclaration","identifier","blockStatement","functionCall","expressionStatement","callExpression","_ast","_options","console","log","oldPath","newPath","ImportDeclaration","source","value","CallExpression","isImport","callee","isStringLiteral","arguments","column","renameSymbol","files","results","Map","file","result","target","extractFunction","updateImports","addImport","importName","importPath","isDefault","importDeclaration","importDefaultSpecifier","stringLiteral","importSpecifier","unshift","removeUnusedImports","usedIdentifiers","Set","findParent","p","isImportDeclaration","add","specifiers","specifier","isImportDefaultSpecifier","local","isImportSpecifier","remove","exports"],"sources":["CodeExecutor.ts"],"sourcesContent":["import * as parser from '@babel/parser';\nimport traverse from '@babel/traverse';\nimport generate from '@babel/generator';\nimport * as t from '@babel/types';\nimport * as fs from 'fs';\n\nexport interface ASTTransform {\n  type: 'rename' | 'extract' | 'move' | 'update-imports' | 'custom';\n  target: string;\n  options: Record<string, any>;\n}\n\nexport interface TransformResult {\n  code: string;\n  success: boolean;\n  error?: string;\n  diagnostics?: Diagnostic[];\n}\n\nexport interface Diagnostic {\n  severity: 'error' | 'warning' | 'info';\n  message: string;\n  line?: number;\n  column?: number;\n}\n\nexport class CodeExecutor {\n  /**\n   * Parse TypeScript/JavaScript code into an AST\n   */\n  parseCode(code: string, filePath: string): parser.ParseResult<t.File> {\n    const isTypeScript = filePath.endsWith('.ts') || filePath.endsWith('.tsx');\n    const isJSX = filePath.endsWith('.tsx') || filePath.endsWith('.jsx');\n\n    return parser.parse(code, {\n      sourceType: 'module',\n      plugins: [\n        isTypeScript && 'typescript',\n        isJSX && 'jsx',\n        'decorators-legacy',\n        'classProperties',\n        'objectRestSpread',\n        'asyncGenerators',\n        'dynamicImport',\n        'optionalChaining',\n        'nullishCoalescingOperator',\n      ].filter(Boolean) as parser.ParserPlugin[],\n    });\n  }\n\n  /**\n   * Generate code from an AST\n   */\n  generateCode(ast: t.File): string {\n    const output = generate(ast, {\n      retainLines: false,\n      compact: false,\n      concise: false,\n      comments: true,\n    });\n\n    return output.code;\n  }\n\n  /**\n   * Apply a transformation to code\n   */\n  async applyTransform(\n    filePath: string,\n    transform: ASTTransform\n  ): Promise<TransformResult> {\n    try {\n      const code = await fs.promises.readFile(filePath, 'utf-8');\n      const ast = this.parseCode(code, filePath);\n\n      // Apply the transformation based on type\n      switch (transform.type) {\n        case 'rename':\n          this.applyRenameTransform(ast, transform.options as { oldName: string; newName: string });\n          break;\n        case 'extract':\n          this.applyExtractTransform(ast, transform.options as { startLine: number; endLine: number; functionName: string });\n          break;\n        case 'move':\n          this.applyMoveTransform(ast, transform.options as { from: string; to: string });\n          break;\n        case 'update-imports':\n          this.applyUpdateImportsTransform(ast, transform.options as { oldPath: string; newPath: string });\n          break;\n        case 'custom':\n          // Custom transformations can be added here\n          break;\n      }\n\n      const transformedCode = this.generateCode(ast);\n      const diagnostics = this.validateSyntax(transformedCode, filePath);\n\n      return {\n        code: transformedCode,\n        success: diagnostics.filter(d => d.severity === 'error').length === 0,\n        diagnostics,\n      };\n    } catch (error) {\n      return {\n        code: '',\n        success: false,\n        error: (error as Error).message,\n      };\n    }\n  }\n\n  /**\n   * Rename a symbol (variable, function, class, etc.)\n   */\n  private applyRenameTransform(ast: t.File, options: { oldName: string; newName: string }): void {\n    const { oldName, newName } = options;\n\n    traverse(ast, {\n      Identifier(nodePath) {\n        if (nodePath.node.name === oldName) {\n          // Check if this is a binding (declaration) or reference\n          const binding = nodePath.scope.getBinding(oldName);\n          if (binding && t.isIdentifier(binding.path.node)) {\n            // Rename all references\n            binding.path.node.name = newName;\n            binding.referencePaths.forEach(refPath => {\n              if (t.isIdentifier(refPath.node)) {\n                refPath.node.name = newName;\n              }\n            });\n          }\n        }\n      },\n    });\n  }\n\n  /**\n   * Extract code into a new function\n   */\n  private applyExtractTransform(\n    ast: t.File,\n    options: { startLine: number; endLine: number; functionName: string }\n  ): void {\n    const { startLine, endLine, functionName } = options;\n\n    traverse(ast, {\n      Program(path) {\n        const statements: t.Statement[] = [];\n        const extractedStatements: t.Statement[] = [];\n\n        // Collect statements to extract\n        path.node.body.forEach((statement) => {\n          const loc = statement.loc;\n          if (loc && loc.start.line >= startLine && loc.end.line <= endLine) {\n            extractedStatements.push(statement);\n          } else {\n            statements.push(statement);\n          }\n        });\n\n        // Create new function with extracted code\n        const newFunction = t.functionDeclaration(\n          t.identifier(functionName),\n          [],\n          t.blockStatement(extractedStatements)\n        );\n\n        // Replace extracted code with function call\n        const functionCall = t.expressionStatement(\n          t.callExpression(t.identifier(functionName), [])\n        );\n\n        // Update program body\n        path.node.body = [...statements, newFunction, functionCall];\n      },\n    });\n  }\n\n  /**\n   * Move code to a different location (placeholder for complex logic)\n   */\n  private applyMoveTransform(_ast: t.File, _options: { from: string; to: string }): void {\n    // This would involve more complex logic to move code between files\n    // For now, this is a placeholder\n    console.log('Move transform not yet implemented');\n  }\n\n  /**\n   * Update import statements\n   */\n  private applyUpdateImportsTransform(\n    ast: t.File,\n    options: { oldPath: string; newPath: string }\n  ): void {\n    const { oldPath, newPath } = options;\n\n    traverse(ast, {\n      ImportDeclaration(path) {\n        if (path.node.source.value === oldPath) {\n          path.node.source.value = newPath;\n        }\n      },\n      // Also handle dynamic imports\n      CallExpression(path) {\n        if (\n          t.isImport(path.node.callee) &&\n          t.isStringLiteral(path.node.arguments[0]) &&\n          path.node.arguments[0].value === oldPath\n        ) {\n          path.node.arguments[0].value = newPath;\n        }\n      },\n    });\n  }\n\n  /**\n   * Validate syntax after transformation\n   */\n  validateSyntax(code: string, filePath: string): Diagnostic[] {\n    const diagnostics: Diagnostic[] = [];\n\n    try {\n      this.parseCode(code, filePath);\n    } catch (error: any) {\n      diagnostics.push({\n        severity: 'error',\n        message: error.message,\n        line: error.loc?.line,\n        column: error.loc?.column,\n      });\n    }\n\n    return diagnostics;\n  }\n\n  /**\n   * Refactor: Rename symbol across multiple files\n   */\n  async renameSymbol(\n    files: string[],\n    oldName: string,\n    newName: string\n  ): Promise<Map<string, TransformResult>> {\n    const results = new Map<string, TransformResult>();\n\n    for (const file of files) {\n      const result = await this.applyTransform(file, {\n        type: 'rename',\n        target: oldName,\n        options: { oldName, newName },\n      });\n      results.set(file, result);\n    }\n\n    return results;\n  }\n\n  /**\n   * Refactor: Extract function\n   */\n  async extractFunction(\n    filePath: string,\n    startLine: number,\n    endLine: number,\n    functionName: string\n  ): Promise<TransformResult> {\n    return this.applyTransform(filePath, {\n      type: 'extract',\n      target: 'function',\n      options: { startLine, endLine, functionName },\n    });\n  }\n\n  /**\n   * Refactor: Update imports across files\n   */\n  async updateImports(\n    files: string[],\n    oldPath: string,\n    newPath: string\n  ): Promise<Map<string, TransformResult>> {\n    const results = new Map<string, TransformResult>();\n\n    for (const file of files) {\n      const result = await this.applyTransform(file, {\n        type: 'update-imports',\n        target: oldPath,\n        options: { oldPath, newPath },\n      });\n      results.set(file, result);\n    }\n\n    return results;\n  }\n\n  /**\n   * Add import statement to a file\n   */\n  async addImport(\n    filePath: string,\n    importName: string,\n    importPath: string,\n    isDefault: boolean = false\n  ): Promise<TransformResult> {\n    try {\n      const code = await fs.promises.readFile(filePath, 'utf-8');\n      const ast = this.parseCode(code, filePath);\n\n      traverse(ast, {\n        Program(path) {\n          const importDeclaration = isDefault\n            ? t.importDeclaration(\n                [t.importDefaultSpecifier(t.identifier(importName))],\n                t.stringLiteral(importPath)\n              )\n            : t.importDeclaration(\n                [t.importSpecifier(t.identifier(importName), t.identifier(importName))],\n                t.stringLiteral(importPath)\n              );\n\n          // Add import at the beginning\n          path.node.body.unshift(importDeclaration);\n        },\n      });\n\n      const transformedCode = this.generateCode(ast);\n      const diagnostics = this.validateSyntax(transformedCode, filePath);\n\n      return {\n        code: transformedCode,\n        success: diagnostics.filter(d => d.severity === 'error').length === 0,\n        diagnostics,\n      };\n    } catch (error) {\n      return {\n        code: '',\n        success: false,\n        error: (error as Error).message,\n      };\n    }\n  }\n\n  /**\n   * Remove unused imports\n   */\n  async removeUnusedImports(filePath: string): Promise<TransformResult> {\n    try {\n      const code = await fs.promises.readFile(filePath, 'utf-8');\n      const ast = this.parseCode(code, filePath);\n\n      const usedIdentifiers = new Set<string>();\n\n      // First pass: collect all used identifiers\n      traverse(ast, {\n        Identifier(path) {\n          // Skip if this is part of an import declaration\n          if (path.findParent(p => p.isImportDeclaration())) {\n            return;\n          }\n          usedIdentifiers.add(path.node.name);\n        },\n      });\n\n      // Second pass: remove unused imports\n      traverse(ast, {\n        ImportDeclaration(path) {\n          const specifiers = path.node.specifiers.filter(specifier => {\n            if (t.isImportDefaultSpecifier(specifier)) {\n              return usedIdentifiers.has(specifier.local.name);\n            }\n            if (t.isImportSpecifier(specifier)) {\n              return usedIdentifiers.has(specifier.local.name);\n            }\n            return true;\n          });\n\n          if (specifiers.length === 0) {\n            path.remove();\n          } else {\n            path.node.specifiers = specifiers;\n          }\n        },\n      });\n\n      const transformedCode = this.generateCode(ast);\n      const diagnostics = this.validateSyntax(transformedCode, filePath);\n\n      return {\n        code: transformedCode,\n        success: diagnostics.filter(d => d.severity === 'error').length === 0,\n        diagnostics,\n      };\n    } catch (error) {\n      return {\n        code: '',\n        success: false,\n        error: (error as Error).message,\n      };\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]}