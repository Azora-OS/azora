{"version":3,"names":["path","_interopRequireWildcard","require","e","t","WeakMap","r","n","__esModule","o","i","f","__proto__","default","has","get","set","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","AuthServiceComponent","generateAuthService","config","outputDir","changes","serviceName","serviceDir","join","push","type","content","generateIndexFile","generateAuthController","generateAuthServiceFile","generateTokenService","generateSessionService","generateUserRepository","generateAuthMiddleware","generateTypes","generateValidationSchemas","generatePrismaSchema","generatePasswordUtils","generatePackageJson","generateEnvExample","generateReadme","port","enableMFA","sessionDuration","resetExpiry","passwordResetExpiry","JSON","stringify","name","version","description","main","scripts","dev","build","start","test","dependencies","express","cors","helmet","zod","jsonwebtoken","bcrypt","speakeasy","qrcode","devDependencies","typescript","jest","prisma","jwtSecret","exports"],"sources":["AuthServiceComponent.ts"],"sourcesContent":["import * as path from 'path';\nimport { FileChange } from '../ChangesetManager';\n\nexport interface AuthServiceConfig {\n  name: string;\n  port?: number;\n  jwtSecret?: string;\n  enableOAuth?: boolean;\n  enableMFA?: boolean;\n  passwordResetExpiry?: number; // in hours\n  sessionDuration?: number; // in hours\n}\n\nexport class AuthServiceComponent {\n  /**\n   * Generate complete JWT authentication system\n   */\n  generateAuthService(config: AuthServiceConfig, outputDir: string): FileChange[] {\n    const changes: FileChange[] = [];\n    const serviceName = 'auth-service';\n    const serviceDir = path.join(outputDir, 'services', serviceName);\n\n    // Main service file\n    changes.push({\n      path: path.join(serviceDir, 'src', 'index.ts'),\n      type: 'create',\n      content: this.generateIndexFile(config),\n    });\n\n    // Controllers\n    changes.push({\n      path: path.join(serviceDir, 'src', 'controllers', 'auth.controller.ts'),\n      type: 'create',\n      content: this.generateAuthController(config),\n    });\n\n    // Services\n    changes.push({\n      path: path.join(serviceDir, 'src', 'services', 'auth.service.ts'),\n      type: 'create',\n      content: this.generateAuthServiceFile(config),\n    });\n\n    changes.push({\n      path: path.join(serviceDir, 'src', 'services', 'token.service.ts'),\n      type: 'create',\n      content: this.generateTokenService(config),\n    });\n\n    changes.push({\n      path: path.join(serviceDir, 'src', 'services', 'session.service.ts'),\n      type: 'create',\n      content: this.generateSessionService(config),\n    });\n\n    // Repository\n    changes.push({\n      path: path.join(serviceDir, 'src', 'repositories', 'user.repository.ts'),\n      type: 'create',\n      content: this.generateUserRepository(),\n    });\n\n    // Middleware\n    changes.push({\n      path: path.join(serviceDir, 'src', 'middleware', 'auth.middleware.ts'),\n      type: 'create',\n      content: this.generateAuthMiddleware(),\n    });\n\n    // Types\n    changes.push({\n      path: path.join(serviceDir, 'src', 'types', 'index.ts'),\n      type: 'create',\n      content: this.generateTypes(config),\n    });\n\n    // Validation schemas\n    changes.push({\n      path: path.join(serviceDir, 'src', 'validation', 'auth.schemas.ts'),\n      type: 'create',\n      content: this.generateValidationSchemas(),\n    });\n\n    // Prisma schema\n    changes.push({\n      path: path.join(serviceDir, 'prisma', 'schema.prisma'),\n      type: 'create',\n      content: this.generatePrismaSchema(config),\n    });\n\n    // Utilities\n    changes.push({\n      path: path.join(serviceDir, 'src', 'utils', 'password.ts'),\n      type: 'create',\n      content: this.generatePasswordUtils(),\n    });\n\n    // Configuration files\n    changes.push({\n      path: path.join(serviceDir, 'package.json'),\n      type: 'create',\n      content: this.generatePackageJson(config),\n    });\n\n    changes.push({\n      path: path.join(serviceDir, '.env.example'),\n      type: 'create',\n      content: this.generateEnvExample(config),\n    });\n\n    changes.push({\n      path: path.join(serviceDir, 'README.md'),\n      type: 'create',\n      content: this.generateReadme(config),\n    });\n\n    return changes;\n  }\n\n  private generateIndexFile(config: AuthServiceConfig): string {\n    const port = config.port || 3001;\n    return `import express, { Application } from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport { AuthController } from './controllers/auth.controller';\nimport { errorHandler } from './middleware/error-handler';\n\nconst app: Application = express();\nconst PORT = process.env.PORT || ${port};\n\n// Middleware\napp.use(helmet());\napp.use(cors({\n  origin: process.env.CORS_ORIGIN || 'http://localhost:3000',\n  credentials: true,\n}));\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\n// Health check\napp.get('/health', (req, res) => {\n  res.json({ status: 'healthy', service: 'auth-service' });\n});\n\n// Routes\nconst authController = new AuthController();\napp.use('/api/auth', authController.router);\n\n// Error handling\napp.use(errorHandler);\n\n// Start server\napp.listen(PORT, () => {\n  console.log(\\`Auth service running on port \\${PORT}\\`);\n});\n\nexport default app;\n`;\n  }\n\n  private generateAuthController(config: AuthServiceConfig): string {\n    return `import { Router, Request, Response, NextFunction } from 'express';\nimport { AuthService } from '../services/auth.service';\nimport { validate } from '../middleware/validation';\nimport { AuthSchemas } from '../validation/auth.schemas';\nimport { authMiddleware } from '../middleware/auth.middleware';\n\nexport class AuthController {\n  public router: Router;\n  private authService: AuthService;\n\n  constructor() {\n    this.router = Router();\n    this.authService = new AuthService();\n    this.initializeRoutes();\n  }\n\n  private initializeRoutes(): void {\n    // Registration\n    this.router.post('/register', validate(AuthSchemas.register), this.register.bind(this));\n    \n    // Login\n    this.router.post('/login', validate(AuthSchemas.login), this.login.bind(this));\n    \n    // Logout\n    this.router.post('/logout', authMiddleware, this.logout.bind(this));\n    \n    // Refresh token\n    this.router.post('/refresh', this.refreshToken.bind(this));\n    \n    // Password reset request\n    this.router.post('/password-reset/request', validate(AuthSchemas.passwordResetRequest), this.requestPasswordReset.bind(this));\n    \n    // Password reset confirm\n    this.router.post('/password-reset/confirm', validate(AuthSchemas.passwordResetConfirm), this.confirmPasswordReset.bind(this));\n    \n    // Get current user\n    this.router.get('/me', authMiddleware, this.getCurrentUser.bind(this));\n    \n    // Update password\n    this.router.put('/password', authMiddleware, validate(AuthSchemas.updatePassword), this.updatePassword.bind(this));\n${config.enableMFA ? `\n    // MFA endpoints\n    this.router.post('/mfa/enable', authMiddleware, this.enableMFA.bind(this));\n    this.router.post('/mfa/verify', authMiddleware, validate(AuthSchemas.verifyMFA), this.verifyMFA.bind(this));\n    this.router.post('/mfa/disable', authMiddleware, this.disableMFA.bind(this));\n` : ''}\n  }\n\n  private async register(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const result = await this.authService.register(req.body);\n      res.status(201).json({ success: true, data: result });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  private async login(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const result = await this.authService.login(req.body);\n      res.json({ success: true, data: result });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  private async logout(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const token = req.headers.authorization?.replace('Bearer ', '');\n      if (token) {\n        await this.authService.logout(token);\n      }\n      res.json({ success: true, message: 'Logged out successfully' });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  private async refreshToken(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const { refreshToken } = req.body;\n      const result = await this.authService.refreshToken(refreshToken);\n      res.json({ success: true, data: result });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  private async requestPasswordReset(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      await this.authService.requestPasswordReset(req.body.email);\n      res.json({ success: true, message: 'Password reset email sent' });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  private async confirmPasswordReset(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      await this.authService.confirmPasswordReset(req.body.token, req.body.newPassword);\n      res.json({ success: true, message: 'Password reset successfully' });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  private async getCurrentUser(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const user = await this.authService.getUserById(req.user!.userId);\n      res.json({ success: true, data: user });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  private async updatePassword(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      await this.authService.updatePassword(req.user!.userId, req.body.currentPassword, req.body.newPassword);\n      res.json({ success: true, message: 'Password updated successfully' });\n    } catch (error) {\n      next(error);\n    }\n  }\n${config.enableMFA ? `\n  private async enableMFA(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      const result = await this.authService.enableMFA(req.user!.userId);\n      res.json({ success: true, data: result });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  private async verifyMFA(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      await this.authService.verifyMFA(req.user!.userId, req.body.code);\n      res.json({ success: true, message: 'MFA verified successfully' });\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  private async disableMFA(req: Request, res: Response, next: NextFunction): Promise<void> {\n    try {\n      await this.authService.disableMFA(req.user!.userId);\n      res.json({ success: true, message: 'MFA disabled successfully' });\n    } catch (error) {\n      next(error);\n    }\n  }\n` : ''}\n}\n`;\n  }\n\n  private generateAuthServiceFile(config: AuthServiceConfig): string {\n    return `import { UserRepository } from '../repositories/user.repository';\nimport { TokenService } from './token.service';\nimport { SessionService } from './session.service';\nimport { hashPassword, verifyPassword } from '../utils/password';\nimport { AppError } from '../middleware/error-handler';\nimport { User, RegisterInput, LoginInput, AuthResponse } from '../types';\n${config.enableMFA ? \"import * as speakeasy from 'speakeasy';\\nimport * as QRCode from 'qrcode';\" : ''}\n\nexport class AuthService {\n  private userRepository: UserRepository;\n  private tokenService: TokenService;\n  private sessionService: SessionService;\n\n  constructor() {\n    this.userRepository = new UserRepository();\n    this.tokenService = new TokenService();\n    this.sessionService = new SessionService();\n  }\n\n  async register(input: RegisterInput): Promise<AuthResponse> {\n    // Check if user already exists\n    const existingUser = await this.userRepository.findByEmail(input.email);\n    if (existingUser) {\n      throw new AppError(400, 'User already exists');\n    }\n\n    // Hash password\n    const hashedPassword = await hashPassword(input.password);\n\n    // Create user\n    const user = await this.userRepository.create({\n      email: input.email,\n      password: hashedPassword,\n      name: input.name,\n    });\n\n    // Generate tokens\n    const { accessToken, refreshToken } = this.tokenService.generateTokens({\n      userId: user.id,\n      email: user.email,\n    });\n\n    // Create session\n    await this.sessionService.createSession(user.id, refreshToken);\n\n    return {\n      user: this.sanitizeUser(user),\n      accessToken,\n      refreshToken,\n    };\n  }\n\n  async login(input: LoginInput): Promise<AuthResponse> {\n    // Find user\n    const user = await this.userRepository.findByEmail(input.email);\n    if (!user) {\n      throw new AppError(401, 'Invalid credentials');\n    }\n\n    // Verify password\n    const isValid = await verifyPassword(input.password, user.password);\n    if (!isValid) {\n      throw new AppError(401, 'Invalid credentials');\n    }\n\n    // Generate tokens\n    const { accessToken, refreshToken } = this.tokenService.generateTokens({\n      userId: user.id,\n      email: user.email,\n    });\n\n    // Create session\n    await this.sessionService.createSession(user.id, refreshToken);\n\n    return {\n      user: this.sanitizeUser(user),\n      accessToken,\n      refreshToken,\n    };\n  }\n\n  async logout(token: string): Promise<void> {\n    await this.sessionService.deleteSessionByToken(token);\n  }\n\n  async refreshToken(refreshToken: string): Promise<{ accessToken: string; refreshToken: string }> {\n    // Verify refresh token\n    const payload = this.tokenService.verifyRefreshToken(refreshToken);\n\n    // Check if session exists\n    const session = await this.sessionService.getSessionByToken(refreshToken);\n    if (!session) {\n      throw new AppError(401, 'Invalid refresh token');\n    }\n\n    // Generate new tokens\n    const tokens = this.tokenService.generateTokens({\n      userId: payload.userId,\n      email: payload.email,\n    });\n\n    // Update session\n    await this.sessionService.updateSession(session.id, tokens.refreshToken);\n\n    return tokens;\n  }\n\n  async requestPasswordReset(email: string): Promise<void> {\n    const user = await this.userRepository.findByEmail(email);\n    if (!user) {\n      // Don't reveal if user exists\n      return;\n    }\n\n    const resetToken = this.tokenService.generatePasswordResetToken(user.id);\n    await this.userRepository.savePasswordResetToken(user.id, resetToken);\n\n    // TODO: Send email with reset token\n    console.log(\\`Password reset token for \\${email}: \\${resetToken}\\`);\n  }\n\n  async confirmPasswordReset(token: string, newPassword: string): Promise<void> {\n    const userId = this.tokenService.verifyPasswordResetToken(token);\n    \n    const user = await this.userRepository.findById(userId);\n    if (!user || user.passwordResetToken !== token) {\n      throw new AppError(400, 'Invalid or expired reset token');\n    }\n\n    const hashedPassword = await hashPassword(newPassword);\n    await this.userRepository.updatePassword(userId, hashedPassword);\n    await this.userRepository.clearPasswordResetToken(userId);\n  }\n\n  async updatePassword(userId: string, currentPassword: string, newPassword: string): Promise<void> {\n    const user = await this.userRepository.findById(userId);\n    if (!user) {\n      throw new AppError(404, 'User not found');\n    }\n\n    const isValid = await verifyPassword(currentPassword, user.password);\n    if (!isValid) {\n      throw new AppError(401, 'Current password is incorrect');\n    }\n\n    const hashedPassword = await hashPassword(newPassword);\n    await this.userRepository.updatePassword(userId, hashedPassword);\n  }\n\n  async getUserById(userId: string): Promise<Partial<User>> {\n    const user = await this.userRepository.findById(userId);\n    if (!user) {\n      throw new AppError(404, 'User not found');\n    }\n    return this.sanitizeUser(user);\n  }\n${config.enableMFA ? `\n  async enableMFA(userId: string): Promise<{ secret: string; qrCode: string }> {\n    const secret = speakeasy.generateSecret({\n      name: 'AzStudio Auth',\n      length: 32,\n    });\n\n    await this.userRepository.saveMFASecret(userId, secret.base32);\n\n    const qrCode = await QRCode.toDataURL(secret.otpauth_url!);\n\n    return {\n      secret: secret.base32,\n      qrCode,\n    };\n  }\n\n  async verifyMFA(userId: string, code: string): Promise<void> {\n    const user = await this.userRepository.findById(userId);\n    if (!user || !user.mfaSecret) {\n      throw new AppError(400, 'MFA not enabled');\n    }\n\n    const verified = speakeasy.totp.verify({\n      secret: user.mfaSecret,\n      encoding: 'base32',\n      token: code,\n    });\n\n    if (!verified) {\n      throw new AppError(401, 'Invalid MFA code');\n    }\n\n    await this.userRepository.enableMFA(userId);\n  }\n\n  async disableMFA(userId: string): Promise<void> {\n    await this.userRepository.disableMFA(userId);\n  }\n` : ''}\n\n  private sanitizeUser(user: User): Partial<User> {\n    const { password, passwordResetToken, mfaSecret, ...sanitized } = user;\n    return sanitized;\n  }\n}\n`;\n  }\n\n  private generateTokenService(config: AuthServiceConfig): string {\n    const sessionDuration = config.sessionDuration || 24;\n    const resetExpiry = config.passwordResetExpiry || 1;\n    \n    return `import jwt from 'jsonwebtoken';\nimport { AppError } from '../middleware/error-handler';\n\nexport interface TokenPayload {\n  userId: string;\n  email: string;\n}\n\nexport class TokenService {\n  private accessTokenSecret: string;\n  private refreshTokenSecret: string;\n  private resetTokenSecret: string;\n\n  constructor() {\n    this.accessTokenSecret = process.env.JWT_ACCESS_SECRET || 'access-secret';\n    this.refreshTokenSecret = process.env.JWT_REFRESH_SECRET || 'refresh-secret';\n    this.resetTokenSecret = process.env.JWT_RESET_SECRET || 'reset-secret';\n  }\n\n  generateTokens(payload: TokenPayload): { accessToken: string; refreshToken: string } {\n    const accessToken = jwt.sign(payload, this.accessTokenSecret, {\n      expiresIn: '15m',\n    });\n\n    const refreshToken = jwt.sign(payload, this.refreshTokenSecret, {\n      expiresIn: '${sessionDuration}h',\n    });\n\n    return { accessToken, refreshToken };\n  }\n\n  verifyAccessToken(token: string): TokenPayload {\n    try {\n      return jwt.verify(token, this.accessTokenSecret) as TokenPayload;\n    } catch (error) {\n      throw new AppError(401, 'Invalid or expired access token');\n    }\n  }\n\n  verifyRefreshToken(token: string): TokenPayload {\n    try {\n      return jwt.verify(token, this.refreshTokenSecret) as TokenPayload;\n    } catch (error) {\n      throw new AppError(401, 'Invalid or expired refresh token');\n    }\n  }\n\n  generatePasswordResetToken(userId: string): string {\n    return jwt.sign({ userId }, this.resetTokenSecret, {\n      expiresIn: '${resetExpiry}h',\n    });\n  }\n\n  verifyPasswordResetToken(token: string): string {\n    try {\n      const payload = jwt.verify(token, this.resetTokenSecret) as { userId: string };\n      return payload.userId;\n    } catch (error) {\n      throw new AppError(400, 'Invalid or expired reset token');\n    }\n  }\n}\n`;\n  }\n\n  private generateSessionService(config: AuthServiceConfig): string {\n    return `import { PrismaClient } from '@prisma/client';\nimport { Session } from '../types';\n\nconst prisma = new PrismaClient();\n\nexport class SessionService {\n  async createSession(userId: string, refreshToken: string): Promise<Session> {\n    return prisma.session.create({\n      data: {\n        userId,\n        refreshToken,\n        expiresAt: new Date(Date.now() + ${(config.sessionDuration || 24) * 60 * 60 * 1000}),\n      },\n    });\n  }\n\n  async getSessionByToken(refreshToken: string): Promise<Session | null> {\n    return prisma.session.findFirst({\n      where: {\n        refreshToken,\n        expiresAt: {\n          gt: new Date(),\n        },\n      },\n    });\n  }\n\n  async updateSession(sessionId: string, newRefreshToken: string): Promise<Session> {\n    return prisma.session.update({\n      where: { id: sessionId },\n      data: {\n        refreshToken: newRefreshToken,\n        expiresAt: new Date(Date.now() + ${(config.sessionDuration || 24) * 60 * 60 * 1000}),\n      },\n    });\n  }\n\n  async deleteSessionByToken(refreshToken: string): Promise<void> {\n    await prisma.session.deleteMany({\n      where: { refreshToken },\n    });\n  }\n\n  async deleteUserSessions(userId: string): Promise<void> {\n    await prisma.session.deleteMany({\n      where: { userId },\n    });\n  }\n\n  async cleanupExpiredSessions(): Promise<void> {\n    await prisma.session.deleteMany({\n      where: {\n        expiresAt: {\n          lt: new Date(),\n        },\n      },\n    });\n  }\n}\n`;\n  }\n\n  private generateUserRepository(): string {\n    return `import { PrismaClient } from '@prisma/client';\nimport { User, CreateUserInput } from '../types';\n\nconst prisma = new PrismaClient();\n\nexport class UserRepository {\n  async findById(id: string): Promise<User | null> {\n    return prisma.user.findUnique({\n      where: { id },\n    });\n  }\n\n  async findByEmail(email: string): Promise<User | null> {\n    return prisma.user.findUnique({\n      where: { email },\n    });\n  }\n\n  async create(data: CreateUserInput): Promise<User> {\n    return prisma.user.create({\n      data,\n    });\n  }\n\n  async updatePassword(userId: string, hashedPassword: string): Promise<User> {\n    return prisma.user.update({\n      where: { id: userId },\n      data: { password: hashedPassword },\n    });\n  }\n\n  async savePasswordResetToken(userId: string, token: string): Promise<User> {\n    return prisma.user.update({\n      where: { id: userId },\n      data: {\n        passwordResetToken: token,\n        passwordResetExpires: new Date(Date.now() + 60 * 60 * 1000), // 1 hour\n      },\n    });\n  }\n\n  async clearPasswordResetToken(userId: string): Promise<User> {\n    return prisma.user.update({\n      where: { id: userId },\n      data: {\n        passwordResetToken: null,\n        passwordResetExpires: null,\n      },\n    });\n  }\n\n  async saveMFASecret(userId: string, secret: string): Promise<User> {\n    return prisma.user.update({\n      where: { id: userId },\n      data: { mfaSecret: secret },\n    });\n  }\n\n  async enableMFA(userId: string): Promise<User> {\n    return prisma.user.update({\n      where: { id: userId },\n      data: { mfaEnabled: true },\n    });\n  }\n\n  async disableMFA(userId: string): Promise<User> {\n    return prisma.user.update({\n      where: { id: userId },\n      data: {\n        mfaEnabled: false,\n        mfaSecret: null,\n      },\n    });\n  }\n}\n`;\n  }\n\n  private generateAuthMiddleware(): string {\n    return `import { Request, Response, NextFunction } from 'express';\nimport { TokenService } from '../services/token.service';\nimport { AppError } from './error-handler';\nimport { TokenPayload } from '../types';\n\ndeclare global {\n  namespace Express {\n    interface Request {\n      user?: TokenPayload;\n    }\n  }\n}\n\nconst tokenService = new TokenService();\n\nexport const authMiddleware = (\n  req: Request,\n  res: Response,\n  next: NextFunction\n): void => {\n  try {\n    const token = req.headers.authorization?.replace('Bearer ', '');\n\n    if (!token) {\n      throw new AppError(401, 'Authentication required');\n    }\n\n    const payload = tokenService.verifyAccessToken(token);\n    req.user = payload;\n    next();\n  } catch (error) {\n    next(error);\n  }\n};\n\nexport const optionalAuth = (\n  req: Request,\n  res: Response,\n  next: NextFunction\n): void => {\n  try {\n    const token = req.headers.authorization?.replace('Bearer ', '');\n\n    if (token) {\n      const payload = tokenService.verifyAccessToken(token);\n      req.user = payload;\n    }\n    next();\n  } catch (error) {\n    // Continue without authentication\n    next();\n  }\n};\n`;\n  }\n\n  private generateTypes(config: AuthServiceConfig): string {\n    return `export interface User {\n  id: string;\n  email: string;\n  password: string;\n  name: string;\n  createdAt: Date;\n  updatedAt: Date;\n  passwordResetToken?: string | null;\n  passwordResetExpires?: Date | null;\n${config.enableMFA ? `  mfaEnabled: boolean;\n  mfaSecret?: string | null;` : ''}\n}\n\nexport interface CreateUserInput {\n  email: string;\n  password: string;\n  name: string;\n}\n\nexport interface RegisterInput {\n  email: string;\n  password: string;\n  name: string;\n}\n\nexport interface LoginInput {\n  email: string;\n  password: string;\n}\n\nexport interface TokenPayload {\n  userId: string;\n  email: string;\n}\n\nexport interface AuthResponse {\n  user: Partial<User>;\n  accessToken: string;\n  refreshToken: string;\n}\n\nexport interface Session {\n  id: string;\n  userId: string;\n  refreshToken: string;\n  expiresAt: Date;\n  createdAt: Date;\n}\n`;\n  }\n\n  private generateValidationSchemas(): string {\n    return `import { z } from 'zod';\n\nexport const AuthSchemas = {\n  register: z.object({\n    body: z.object({\n      email: z.string().email('Invalid email address'),\n      password: z.string().min(8, 'Password must be at least 8 characters'),\n      name: z.string().min(1, 'Name is required'),\n    }),\n  }),\n\n  login: z.object({\n    body: z.object({\n      email: z.string().email('Invalid email address'),\n      password: z.string().min(1, 'Password is required'),\n    }),\n  }),\n\n  passwordResetRequest: z.object({\n    body: z.object({\n      email: z.string().email('Invalid email address'),\n    }),\n  }),\n\n  passwordResetConfirm: z.object({\n    body: z.object({\n      token: z.string().min(1, 'Token is required'),\n      newPassword: z.string().min(8, 'Password must be at least 8 characters'),\n    }),\n  }),\n\n  updatePassword: z.object({\n    body: z.object({\n      currentPassword: z.string().min(1, 'Current password is required'),\n      newPassword: z.string().min(8, 'New password must be at least 8 characters'),\n    }),\n  }),\n\n  verifyMFA: z.object({\n    body: z.object({\n      code: z.string().length(6, 'MFA code must be 6 digits'),\n    }),\n  }),\n};\n`;\n  }\n\n  private generatePrismaSchema(config: AuthServiceConfig): string {\n    return `generator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n  id        String   @id @default(cuid())\n  email     String   @unique\n  password  String\n  name      String\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  \n  passwordResetToken   String?\n  passwordResetExpires DateTime?\n${config.enableMFA ? `  \n  mfaEnabled Boolean  @default(false)\n  mfaSecret  String?` : ''}\n  \n  sessions Session[]\n  \n  @@map(\"users\")\n}\n\nmodel Session {\n  id           String   @id @default(cuid())\n  userId       String\n  refreshToken String   @unique\n  expiresAt    DateTime\n  createdAt    DateTime @default(now())\n  \n  user User @relation(fields: [userId], references: [id], onDelete: Cascade)\n  \n  @@index([userId])\n  @@index([refreshToken])\n  @@map(\"sessions\")\n}\n`;\n  }\n\n  private generatePasswordUtils(): string {\n    return `import * as bcrypt from 'bcrypt';\n\nconst SALT_ROUNDS = 10;\n\nexport async function hashPassword(password: string): Promise<string> {\n  return bcrypt.hash(password, SALT_ROUNDS);\n}\n\nexport async function verifyPassword(password: string, hash: string): Promise<boolean> {\n  return bcrypt.compare(password, hash);\n}\n`;\n  }\n\n  private generatePackageJson(config: AuthServiceConfig): string {\n    return JSON.stringify({\n      name: 'auth-service',\n      version: '1.0.0',\n      description: 'JWT Authentication Service',\n      main: 'dist/index.js',\n      scripts: {\n        dev: 'ts-node-dev --respawn --transpile-only src/index.ts',\n        build: 'tsc',\n        start: 'node dist/index.js',\n        test: 'jest',\n        'test:watch': 'jest --watch',\n        'prisma:generate': 'prisma generate',\n        'prisma:migrate': 'prisma migrate dev',\n      },\n      dependencies: {\n        express: '^4.18.2',\n        cors: '^2.8.5',\n        helmet: '^7.1.0',\n        zod: '^3.22.4',\n        '@prisma/client': '^5.7.1',\n        jsonwebtoken: '^9.0.2',\n        bcrypt: '^5.1.1',\n        ...(config.enableMFA && {\n          speakeasy: '^2.0.0',\n          qrcode: '^1.5.3',\n        }),\n      },\n      devDependencies: {\n        '@types/express': '^4.17.21',\n        '@types/cors': '^2.8.17',\n        '@types/node': '^20.10.5',\n        '@types/jsonwebtoken': '^9.0.5',\n        '@types/bcrypt': '^5.0.2',\n        typescript: '^5.3.3',\n        'ts-node-dev': '^2.0.0',\n        jest: '^29.7.0',\n        '@types/jest': '^29.5.11',\n        'ts-jest': '^29.1.1',\n        prisma: '^5.7.1',\n        ...(config.enableMFA && {\n          '@types/speakeasy': '^2.0.10',\n          '@types/qrcode': '^1.5.5',\n        }),\n      },\n    }, null, 2);\n  }\n\n  private generateEnvExample(config: AuthServiceConfig): string {\n    return `PORT=${config.port || 3001}\nNODE_ENV=development\nCORS_ORIGIN=http://localhost:3000\n\nDATABASE_URL=postgresql://user:password@localhost:5432/auth_db\n\nJWT_ACCESS_SECRET=${config.jwtSecret || 'your-access-secret-key'}\nJWT_REFRESH_SECRET=your-refresh-secret-key\nJWT_RESET_SECRET=your-reset-secret-key\n`;\n  }\n\n  private generateReadme(config: AuthServiceConfig): string {\n    return `# Auth Service\n\nJWT-based authentication service with user registration, login, password reset, and session management.\n\n## Features\n\n- User registration and login\n- JWT access and refresh tokens\n- Password reset flow\n- Session management\n${config.enableMFA ? '- Multi-factor authentication (MFA)\\n' : ''}- Secure password hashing with bcrypt\n\n## Installation\n\n\\`\\`\\`bash\nnpm install\n\\`\\`\\`\n\n## Database Setup\n\n\\`\\`\\`bash\nnpx prisma migrate dev\nnpx prisma generate\n\\`\\`\\`\n\n## Configuration\n\nCopy \\`.env.example\\` to \\`.env\\` and configure:\n\n- \\`DATABASE_URL\\`: PostgreSQL connection string\n- \\`JWT_ACCESS_SECRET\\`: Secret for access tokens\n- \\`JWT_REFRESH_SECRET\\`: Secret for refresh tokens\n- \\`JWT_RESET_SECRET\\`: Secret for password reset tokens\n\n## Development\n\n\\`\\`\\`bash\nnpm run dev\n\\`\\`\\`\n\n## Production\n\n\\`\\`\\`bash\nnpm run build\nnpm start\n\\`\\`\\`\n\n## API Endpoints\n\n### Authentication\n- \\`POST /api/auth/register\\` - Register new user\n- \\`POST /api/auth/login\\` - Login user\n- \\`POST /api/auth/logout\\` - Logout user\n- \\`POST /api/auth/refresh\\` - Refresh access token\n\n### Password Management\n- \\`POST /api/auth/password-reset/request\\` - Request password reset\n- \\`POST /api/auth/password-reset/confirm\\` - Confirm password reset\n- \\`PUT /api/auth/password\\` - Update password (authenticated)\n\n### User\n- \\`GET /api/auth/me\\` - Get current user (authenticated)\n${config.enableMFA ? `\n### MFA\n- \\`POST /api/auth/mfa/enable\\` - Enable MFA (authenticated)\n- \\`POST /api/auth/mfa/verify\\` - Verify MFA code (authenticated)\n- \\`POST /api/auth/mfa/disable\\` - Disable MFA (authenticated)\n` : ''}\n## Testing\n\n\\`\\`\\`bash\nnpm test\n\\`\\`\\`\n`;\n  }\n}\n"],"mappings":"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EAAE,WAAW,CAAC;MACxCG,IAAI,EAAE,QAAQ;MACdC,OAAO,EAAE,IAAI,CAACc,cAAc,CAACtB,MAAM;IACrC,CAAC,CAAC;IAEF,OAAOE,OAAO;EAChB;EAEQO,iBAAiBA,CAACT,MAAyB,EAAU;IAC3D,MAAMuB,IAAI,GAAGvB,MAAM,CAACuB,IAAI,IAAI,IAAI;IAChC,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmCA,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;EACC;EAEQb,sBAAsBA,CAACV,MAAyB,EAAU;IAChE,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAEA,MAAM,CAACwB,SAAS,GAAG;AACrB;AACA;AACA;AACA;AACA,CAAC,GAAG,EAAE;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAExB,MAAM,CAACwB,SAAS,GAAG;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,EAAE;AACN;AACA,CAAC;EACC;EAEQb,uBAAuBA,CAACX,MAAyB,EAAU;IACjE,OAAO;AACX;AACA;AACA;AACA;AACA;AACA,EAAEA,MAAM,CAACwB,SAAS,GAAG,4EAA4E,GAAG,EAAE;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAExB,MAAM,CAACwB,SAAS,GAAG;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,EAAE;AACN;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;EACC;EAEQZ,oBAAoBA,CAACZ,MAAyB,EAAU;IAC9D,MAAMyB,eAAe,GAAGzB,MAAM,CAACyB,eAAe,IAAI,EAAE;IACpD,MAAMC,WAAW,GAAG1B,MAAM,CAAC2B,mBAAmB,IAAI,CAAC;IAEnD,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoBF,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoBC,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;EACC;EAEQb,sBAAsBA,CAACb,MAAyB,EAAU;IAChE,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,CAACA,MAAM,CAACyB,eAAe,IAAI,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,IAAI;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,CAACzB,MAAM,CAACyB,eAAe,IAAI,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,IAAI;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;EACC;EAEQX,sBAAsBA,CAAA,EAAW;IACvC,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;EACC;EAEQC,sBAAsBA,CAAA,EAAW;IACvC,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;EACC;EAEQC,aAAaA,CAAChB,MAAyB,EAAU;IACvD,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAEA,MAAM,CAACwB,SAAS,GAAG;AACrB,6BAA6B,GAAG,EAAE;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;EACC;EAEQP,yBAAyBA,CAAA,EAAW;IAC1C,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;EACC;EAEQC,oBAAoBA,CAAClB,MAAyB,EAAU;IAC9D,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAEA,MAAM,CAACwB,SAAS,GAAG;AACrB;AACA,qBAAqB,GAAG,EAAE;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;EACC;EAEQL,qBAAqBA,CAAA,EAAW;IACtC,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;EACC;EAEQC,mBAAmBA,CAACpB,MAAyB,EAAU;IAC7D,OAAO4B,IAAI,CAACC,SAAS,CAAC;MACpBC,IAAI,EAAE,cAAc;MACpBC,OAAO,EAAE,OAAO;MAChBC,WAAW,EAAE,4BAA4B;MACzCC,IAAI,EAAE,eAAe;MACrBC,OAAO,EAAE;QACPC,GAAG,EAAE,qDAAqD;QAC1DC,KAAK,EAAE,KAAK;QACZC,KAAK,EAAE,oBAAoB;QAC3BC,IAAI,EAAE,MAAM;QACZ,YAAY,EAAE,cAAc;QAC5B,iBAAiB,EAAE,iBAAiB;QACpC,gBAAgB,EAAE;MACpB,CAAC;MACDC,YAAY,EAAE;QACZC,OAAO,EAAE,SAAS;QAClBC,IAAI,EAAE,QAAQ;QACdC,MAAM,EAAE,QAAQ;QAChBC,GAAG,EAAE,SAAS;QACd,gBAAgB,EAAE,QAAQ;QAC1BC,YAAY,EAAE,QAAQ;QACtBC,MAAM,EAAE,QAAQ;QAChB,IAAI7C,MAAM,CAACwB,SAAS,IAAI;UACtBsB,SAAS,EAAE,QAAQ;UACnBC,MAAM,EAAE;QACV,CAAC;MACH,CAAC;MACDC,eAAe,EAAE;QACf,gBAAgB,EAAE,UAAU;QAC5B,aAAa,EAAE,SAAS;QACxB,aAAa,EAAE,UAAU;QACzB,qBAAqB,EAAE,QAAQ;QAC/B,eAAe,EAAE,QAAQ;QACzBC,UAAU,EAAE,QAAQ;QACpB,aAAa,EAAE,QAAQ;QACvBC,IAAI,EAAE,SAAS;QACf,aAAa,EAAE,UAAU;QACzB,SAAS,EAAE,SAAS;QACpBC,MAAM,EAAE,QAAQ;QAChB,IAAInD,MAAM,CAACwB,SAAS,IAAI;UACtB,kBAAkB,EAAE,SAAS;UAC7B,eAAe,EAAE;QACnB,CAAC;MACH;IACF,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC;EACb;EAEQH,kBAAkBA,CAACrB,MAAyB,EAAU;IAC5D,OAAO,QAAQA,MAAM,CAACuB,IAAI,IAAI,IAAI;AACtC;AACA;AACA;AACA;AACA;AACA,oBAAoBvB,MAAM,CAACoD,SAAS,IAAI,wBAAwB;AAChE;AACA;AACA,CAAC;EACC;EAEQ9B,cAAcA,CAACtB,MAAyB,EAAU;IACxD,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAEA,MAAM,CAACwB,SAAS,GAAG,uCAAuC,GAAG,EAAE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAExB,MAAM,CAACwB,SAAS,GAAG;AACrB;AACA;AACA;AACA;AACA,CAAC,GAAG,EAAE;AACN;AACA;AACA;AACA;AACA;AACA,CAAC;EACC;AACF;AAAC6B,OAAA,CAAAvD,oBAAA,GAAAA,oBAAA","ignoreList":[]}