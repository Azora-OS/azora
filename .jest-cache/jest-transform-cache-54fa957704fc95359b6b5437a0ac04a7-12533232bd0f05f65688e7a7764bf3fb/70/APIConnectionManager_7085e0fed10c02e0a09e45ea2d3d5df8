012c8412195c66b17eb31c64823b6c84
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.APIConnectionManager = void 0;
var path = _interopRequireWildcard(require("path"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
class APIConnectionManager {
  /**
   * Generate React Query hooks for API connections
   */
  generateReactQueryHook(options, outputDir) {
    const changes = [];
    const hookPath = path.join(outputDir, 'hooks', `${this.toKebabCase(options.hookName)}.ts`);
    changes.push({
      path: hookPath,
      type: 'create',
      content: this.generateHookContent(options)
    });
    return changes;
  }

  /**
   * Generate hook content based on operation type
   */
  generateHookContent(options) {
    const {
      hookName,
      endpoint,
      connection
    } = options;
    if (connection.operation === 'query') {
      return this.generateQueryHook(hookName, endpoint, connection);
    } else {
      return this.generateMutationHook(hookName, endpoint, connection);
    }
  }

  /**
   * Generate a React Query useQuery hook
   */
  generateQueryHook(hookName, endpoint, _connection) {
    const functionName = this.toCamelCase(hookName);
    const queryKey = this.generateQueryKey(endpoint);
    const fetchFunction = this.generateFetchFunction(endpoint);
    return `import { useQuery, UseQueryOptions } from '@tanstack/react-query';

${this.generateTypeDefinitions(endpoint)}

${fetchFunction}

export function ${functionName}(
  ${this.generateHookParameters(endpoint)},
  options?: Omit<UseQueryOptions<${this.getResponseType(endpoint)}, Error>, 'queryKey' | 'queryFn'>
) {
  return useQuery({
    queryKey: ${queryKey},
    queryFn: () => fetch${this.toPascalCase(hookName)}(${this.generateFetchParams(endpoint)}),
    ...options,
  });
}

// Usage example:
// const { data, isLoading, error, refetch } = ${functionName}();
`;
  }

  /**
   * Generate a React Query useMutation hook
   */
  generateMutationHook(hookName, endpoint, connection) {
    const functionName = this.toCamelCase(hookName);
    const fetchFunction = this.generateFetchFunction(endpoint);
    const hasOptimistic = connection.optimisticUpdate;
    return `import { useMutation, useQueryClient, UseMutationOptions } from '@tanstack/react-query';

${this.generateTypeDefinitions(endpoint)}

${fetchFunction}

export function ${functionName}(
  options?: UseMutationOptions<${this.getResponseType(endpoint)}, Error, ${this.getRequestType(endpoint)}>
) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: fetch${this.toPascalCase(hookName)},
    ${hasOptimistic ? this.generateOptimisticUpdate(endpoint) : ''}
    onSuccess: (data) => {
      // Invalidate and refetch related queries
      queryClient.invalidateQueries({ queryKey: ['${this.getResourceName(endpoint)}'] });
      ${connection.onSuccess ? `options?.onSuccess?.(data);` : ''}
    },
    onError: (error) => {
      console.error('Mutation error:', error);
      ${connection.onError ? `options?.onError?.(error);` : ''}
    },
    ...options,
  });
}

// Usage example:
// const mutation = ${functionName}();
// mutation.mutate(${this.getRequestType(endpoint) !== 'void' ? '{ /* data */ }' : ''});
`;
  }

  /**
   * Generate fetch function for API endpoint
   */
  generateFetchFunction(endpoint) {
    const functionName = `fetch${this.toPascalCase(endpoint.id)}`;
    const hasRequestBody = ['POST', 'PUT', 'PATCH'].includes(endpoint.method);
    const params = hasRequestBody ? `data: ${this.getRequestType(endpoint)}` : this.generatePathParams(endpoint);
    return `async function ${functionName}(${params}): Promise<${this.getResponseType(endpoint)}> {
  const response = await fetch(\`\${process.env.NEXT_PUBLIC_API_URL || ''}${this.interpolatePath(endpoint.path)}\`, {
    method: '${endpoint.method}',
    headers: {
      'Content-Type': 'application/json',
      ${endpoint.requiresAuth ? `'Authorization': \`Bearer \${localStorage.getItem('token')}\`,` : ''}
    },
    ${hasRequestBody ? 'body: JSON.stringify(data),' : ''}
  });

  if (!response.ok) {
    throw new Error(\`API error: \${response.status} \${response.statusText}\`);
  }

  return response.json();
}
`;
  }

  /**
   * Generate TypeScript type definitions from schemas
   */
  generateTypeDefinitions(endpoint) {
    const types = [];
    if (endpoint.requestSchema) {
      types.push(`export interface ${this.toPascalCase(endpoint.id)}Request {
  ${this.schemaToTypeFields(endpoint.requestSchema)}
}`);
    }
    if (endpoint.responseSchema) {
      types.push(`export interface ${this.toPascalCase(endpoint.id)}Response {
  ${this.schemaToTypeFields(endpoint.responseSchema)}
}`);
    }
    return types.join('\n\n');
  }

  /**
   * Convert schema object to TypeScript interface fields
   */
  schemaToTypeFields(schema) {
    return Object.entries(schema).map(([key, value]) => {
      const type = this.inferTypeFromSchema(value);
      const optional = value.optional ? '?' : '';
      return `  ${key}${optional}: ${type};`;
    }).join('\n');
  }

  /**
   * Infer TypeScript type from schema definition
   */
  inferTypeFromSchema(value) {
    if (typeof value === 'string') {
      return value; // Already a type string
    }
    if (value.type === 'array') {
      return `${this.inferTypeFromSchema(value.items)}[]`;
    }
    if (value.type === 'object') {
      return 'Record<string, any>'; // Simplified for now
    }
    const typeMap = {
      string: 'string',
      number: 'number',
      boolean: 'boolean',
      date: 'Date',
      any: 'any'
    };
    return typeMap[value.type] || 'any';
  }

  /**
   * Generate query key for React Query
   */
  generateQueryKey(endpoint) {
    const resourceName = this.getResourceName(endpoint);
    const pathParams = this.extractPathParams(endpoint.path);
    if (pathParams.length > 0) {
      return `['${resourceName}', ${pathParams.join(', ')}]`;
    }
    return `['${resourceName}']`;
  }

  /**
   * Extract resource name from endpoint path
   */
  getResourceName(endpoint) {
    // Extract first non-api path segment as resource name
    const match = endpoint.path.match(/^\/(?:api\/)?([^\/]+)/);
    return match ? match[1] : 'resource';
  }

  /**
   * Extract path parameters from endpoint path
   */
  extractPathParams(path) {
    const matches = path.match(/:(\w+)/g);
    return matches ? matches.map(m => m.substring(1)) : [];
  }

  /**
   * Generate path parameters for function signature
   */
  generatePathParams(endpoint) {
    const params = this.extractPathParams(endpoint.path);
    return params.map(p => `${p}: string | number`).join(', ');
  }

  /**
   * Interpolate path parameters in endpoint path
   */
  interpolatePath(path) {
    return path.replace(/:(\w+)/g, '${$1}');
  }

  /**
   * Generate fetch function parameters
   */
  generateFetchParams(endpoint) {
    const params = this.extractPathParams(endpoint.path);
    return params.join(', ');
  }

  /**
   * Generate hook parameters
   */
  generateHookParameters(endpoint) {
    const params = this.extractPathParams(endpoint.path);
    if (params.length === 0) return '';
    return params.map(p => `${p}: string | number`).join(', ');
  }

  /**
   * Get request type name
   */
  getRequestType(endpoint) {
    if (!endpoint.requestSchema) return 'void';
    return `${this.toPascalCase(endpoint.id)}Request`;
  }

  /**
   * Get response type name
   */
  getResponseType(endpoint) {
    if (!endpoint.responseSchema) return 'any';
    return `${this.toPascalCase(endpoint.id)}Response`;
  }

  /**
   * Generate optimistic update logic
   */
  generateOptimisticUpdate(endpoint) {
    const resourceName = this.getResourceName(endpoint);
    return `onMutate: async (newData) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ['${resourceName}'] });

      // Snapshot previous value
      const previousData = queryClient.getQueryData(['${resourceName}']);

      // Optimistically update
      queryClient.setQueryData(['${resourceName}'], (old: any) => {
        // Implement optimistic update logic based on your data structure
        return newData;
      });

      // Return context with snapshot
      return { previousData };
    },
    onError: (err, newData, context) => {
      // Rollback on error
      if (context?.previousData) {
        queryClient.setQueryData(['${resourceName}'], context.previousData);
      }
    },`;
  }

  /**
   * Generate component with API connection
   */
  generateConnectedComponent(componentId, endpoint, connection, outputDir) {
    const changes = [];
    const componentPath = path.join(outputDir, 'components', `${this.toKebabCase(componentId)}.tsx`);
    const hookName = `use${this.toPascalCase(endpoint.id)}`;

    // Generate the hook first
    changes.push(...this.generateReactQueryHook({
      hookName,
      endpoint,
      connection
    }, outputDir));

    // Generate component that uses the hook
    changes.push({
      path: componentPath,
      type: 'create',
      content: this.generateComponentWithHook(componentId, hookName, connection)
    });
    return changes;
  }

  /**
   * Generate component code that uses the API hook
   */
  generateComponentWithHook(componentId, hookName, connection) {
    const componentName = this.toPascalCase(componentId);
    const isQuery = connection.operation === 'query';
    if (isQuery) {
      return `'use client';

import React from 'react';
import { ${this.toCamelCase(hookName)} } from '@/hooks/${this.toKebabCase(hookName)}';

export default function ${componentName}() {
  const { data, isLoading, error, refetch } = ${this.toCamelCase(hookName)}();

  if (isLoading) {
    return (
      <div className="flex items-center justify-center p-8">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="bg-red-50 border border-red-200 rounded-md p-4">
        <p className="text-red-800">Error: {error.message}</p>
        <button 
          onClick={() => refetch()}
          className="mt-2 px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700"
        >
          Retry
        </button>
      </div>
    );
  }

  return (
    <div className="p-4">
      {/* Render your data here */}
      <pre className="bg-gray-100 p-4 rounded-md overflow-auto">
        {JSON.stringify(data, null, 2)}
      </pre>
    </div>
  );
}
`;
    } else {
      return `'use client';

import React from 'react';
import { ${this.toCamelCase(hookName)} } from '@/hooks/${this.toKebabCase(hookName)}';

export default function ${componentName}() {
  const mutation = ${this.toCamelCase(hookName)}();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    // Collect form data and call mutation
    mutation.mutate({
      // Add your data here
    });
  };

  return (
    <div className="p-4">
      <form onSubmit={handleSubmit} className="space-y-4">
        {/* Add your form fields here */}
        
        <button 
          type="submit"
          disabled={mutation.isPending}
          className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:opacity-50"
        >
          {mutation.isPending ? 'Submitting...' : 'Submit'}
        </button>

        {mutation.isError && (
          <div className="bg-red-50 border border-red-200 rounded-md p-4">
            <p className="text-red-800">Error: {mutation.error.message}</p>
          </div>
        )}

        {mutation.isSuccess && (
          <div className="bg-green-50 border border-green-200 rounded-md p-4">
            <p className="text-green-800">Success!</p>
          </div>
        )}
      </form>
    </div>
  );
}
`;
    }
  }

  /**
   * Convert string to PascalCase
   */
  toPascalCase(str) {
    return str.replace(/[-_\s:]+(.)?/g, (_, c) => c ? c.toUpperCase() : '').replace(/^[a-z]/, c => c.toUpperCase());
  }

  /**
   * Convert string to camelCase
   */
  toCamelCase(str) {
    const pascal = this.toPascalCase(str);
    return pascal.charAt(0).toLowerCase() + pascal.slice(1);
  }

  /**
   * Convert string to kebab-case
   */
  toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').replace(/[\s_:]+/g, '-').toLowerCase();
  }
}
exports.APIConnectionManager = APIConnectionManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJwYXRoIiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJyZXF1aXJlIiwiZSIsInQiLCJXZWFrTWFwIiwiciIsIm4iLCJfX2VzTW9kdWxlIiwibyIsImkiLCJmIiwiX19wcm90b19fIiwiZGVmYXVsdCIsImhhcyIsImdldCIsInNldCIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiQVBJQ29ubmVjdGlvbk1hbmFnZXIiLCJnZW5lcmF0ZVJlYWN0UXVlcnlIb29rIiwib3B0aW9ucyIsIm91dHB1dERpciIsImNoYW5nZXMiLCJob29rUGF0aCIsImpvaW4iLCJ0b0tlYmFiQ2FzZSIsImhvb2tOYW1lIiwicHVzaCIsInR5cGUiLCJjb250ZW50IiwiZ2VuZXJhdGVIb29rQ29udGVudCIsImVuZHBvaW50IiwiY29ubmVjdGlvbiIsIm9wZXJhdGlvbiIsImdlbmVyYXRlUXVlcnlIb29rIiwiZ2VuZXJhdGVNdXRhdGlvbkhvb2siLCJfY29ubmVjdGlvbiIsImZ1bmN0aW9uTmFtZSIsInRvQ2FtZWxDYXNlIiwicXVlcnlLZXkiLCJnZW5lcmF0ZVF1ZXJ5S2V5IiwiZmV0Y2hGdW5jdGlvbiIsImdlbmVyYXRlRmV0Y2hGdW5jdGlvbiIsImdlbmVyYXRlVHlwZURlZmluaXRpb25zIiwiZ2VuZXJhdGVIb29rUGFyYW1ldGVycyIsImdldFJlc3BvbnNlVHlwZSIsInRvUGFzY2FsQ2FzZSIsImdlbmVyYXRlRmV0Y2hQYXJhbXMiLCJoYXNPcHRpbWlzdGljIiwib3B0aW1pc3RpY1VwZGF0ZSIsImdldFJlcXVlc3RUeXBlIiwiZ2VuZXJhdGVPcHRpbWlzdGljVXBkYXRlIiwiZ2V0UmVzb3VyY2VOYW1lIiwib25TdWNjZXNzIiwib25FcnJvciIsImlkIiwiaGFzUmVxdWVzdEJvZHkiLCJpbmNsdWRlcyIsIm1ldGhvZCIsInBhcmFtcyIsImdlbmVyYXRlUGF0aFBhcmFtcyIsImludGVycG9sYXRlUGF0aCIsInJlcXVpcmVzQXV0aCIsInR5cGVzIiwicmVxdWVzdFNjaGVtYSIsInNjaGVtYVRvVHlwZUZpZWxkcyIsInJlc3BvbnNlU2NoZW1hIiwic2NoZW1hIiwiZW50cmllcyIsIm1hcCIsImtleSIsInZhbHVlIiwiaW5mZXJUeXBlRnJvbVNjaGVtYSIsIm9wdGlvbmFsIiwiaXRlbXMiLCJ0eXBlTWFwIiwic3RyaW5nIiwibnVtYmVyIiwiYm9vbGVhbiIsImRhdGUiLCJhbnkiLCJyZXNvdXJjZU5hbWUiLCJwYXRoUGFyYW1zIiwiZXh0cmFjdFBhdGhQYXJhbXMiLCJsZW5ndGgiLCJtYXRjaCIsIm1hdGNoZXMiLCJtIiwic3Vic3RyaW5nIiwicCIsInJlcGxhY2UiLCJnZW5lcmF0ZUNvbm5lY3RlZENvbXBvbmVudCIsImNvbXBvbmVudElkIiwiY29tcG9uZW50UGF0aCIsImdlbmVyYXRlQ29tcG9uZW50V2l0aEhvb2siLCJjb21wb25lbnROYW1lIiwiaXNRdWVyeSIsInN0ciIsIl8iLCJjIiwidG9VcHBlckNhc2UiLCJwYXNjYWwiLCJjaGFyQXQiLCJ0b0xvd2VyQ2FzZSIsInNsaWNlIiwiZXhwb3J0cyJdLCJzb3VyY2VzIjpbIkFQSUNvbm5lY3Rpb25NYW5hZ2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEZpbGVDaGFuZ2UgfSBmcm9tICcuL0NoYW5nZXNldE1hbmFnZXInO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcblxuZXhwb3J0IGludGVyZmFjZSBBUElFbmRwb2ludCB7XG4gIGlkOiBzdHJpbmc7XG4gIG1ldGhvZDogJ0dFVCcgfCAnUE9TVCcgfCAnUFVUJyB8ICdQQVRDSCcgfCAnREVMRVRFJztcbiAgcGF0aDogc3RyaW5nO1xuICByZXF1ZXN0U2NoZW1hPzogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgcmVzcG9uc2VTY2hlbWE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICByZXF1aXJlc0F1dGg/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFQSUNvbm5lY3Rpb24ge1xuICBjb21wb25lbnRJZDogc3RyaW5nO1xuICBlbmRwb2ludElkOiBzdHJpbmc7XG4gIG9wZXJhdGlvbjogJ3F1ZXJ5JyB8ICdtdXRhdGlvbic7XG4gIG9uU3VjY2Vzcz86IHN0cmluZzsgLy8gQ2FsbGJhY2sgZnVuY3Rpb24gbmFtZVxuICBvbkVycm9yPzogc3RyaW5nOyAvLyBFcnJvciBoYW5kbGVyIGZ1bmN0aW9uIG5hbWVcbiAgb3B0aW1pc3RpY1VwZGF0ZT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVhY3RRdWVyeUhvb2tPcHRpb25zIHtcbiAgaG9va05hbWU6IHN0cmluZztcbiAgZW5kcG9pbnQ6IEFQSUVuZHBvaW50O1xuICBjb25uZWN0aW9uOiBBUElDb25uZWN0aW9uO1xuICBpbmNsdWRlT3B0aW1pc3RpY1VwZGF0ZXM/OiBib29sZWFuO1xufVxuXG5leHBvcnQgY2xhc3MgQVBJQ29ubmVjdGlvbk1hbmFnZXIge1xuICAvKipcbiAgICogR2VuZXJhdGUgUmVhY3QgUXVlcnkgaG9va3MgZm9yIEFQSSBjb25uZWN0aW9uc1xuICAgKi9cbiAgZ2VuZXJhdGVSZWFjdFF1ZXJ5SG9vayhvcHRpb25zOiBSZWFjdFF1ZXJ5SG9va09wdGlvbnMsIG91dHB1dERpcjogc3RyaW5nKTogRmlsZUNoYW5nZVtdIHtcbiAgICBjb25zdCBjaGFuZ2VzOiBGaWxlQ2hhbmdlW10gPSBbXTtcbiAgICBjb25zdCBob29rUGF0aCA9IHBhdGguam9pbihvdXRwdXREaXIsICdob29rcycsIGAke3RoaXMudG9LZWJhYkNhc2Uob3B0aW9ucy5ob29rTmFtZSl9LnRzYCk7XG4gICAgXG4gICAgY2hhbmdlcy5wdXNoKHtcbiAgICAgIHBhdGg6IGhvb2tQYXRoLFxuICAgICAgdHlwZTogJ2NyZWF0ZScsXG4gICAgICBjb250ZW50OiB0aGlzLmdlbmVyYXRlSG9va0NvbnRlbnQob3B0aW9ucyksXG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2hhbmdlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBob29rIGNvbnRlbnQgYmFzZWQgb24gb3BlcmF0aW9uIHR5cGVcbiAgICovXG4gIHByaXZhdGUgZ2VuZXJhdGVIb29rQ29udGVudChvcHRpb25zOiBSZWFjdFF1ZXJ5SG9va09wdGlvbnMpOiBzdHJpbmcge1xuICAgIGNvbnN0IHsgaG9va05hbWUsIGVuZHBvaW50LCBjb25uZWN0aW9uIH0gPSBvcHRpb25zO1xuICAgIFxuICAgIGlmIChjb25uZWN0aW9uLm9wZXJhdGlvbiA9PT0gJ3F1ZXJ5Jykge1xuICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVRdWVyeUhvb2soaG9va05hbWUsIGVuZHBvaW50LCBjb25uZWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVNdXRhdGlvbkhvb2soaG9va05hbWUsIGVuZHBvaW50LCBjb25uZWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBSZWFjdCBRdWVyeSB1c2VRdWVyeSBob29rXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlUXVlcnlIb29rKGhvb2tOYW1lOiBzdHJpbmcsIGVuZHBvaW50OiBBUElFbmRwb2ludCwgX2Nvbm5lY3Rpb246IEFQSUNvbm5lY3Rpb24pOiBzdHJpbmcge1xuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IHRoaXMudG9DYW1lbENhc2UoaG9va05hbWUpO1xuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gdGhpcy5nZW5lcmF0ZVF1ZXJ5S2V5KGVuZHBvaW50KTtcbiAgICBjb25zdCBmZXRjaEZ1bmN0aW9uID0gdGhpcy5nZW5lcmF0ZUZldGNoRnVuY3Rpb24oZW5kcG9pbnQpO1xuICAgIFxuICAgIHJldHVybiBgaW1wb3J0IHsgdXNlUXVlcnksIFVzZVF1ZXJ5T3B0aW9ucyB9IGZyb20gJ0B0YW5zdGFjay9yZWFjdC1xdWVyeSc7XG5cbiR7dGhpcy5nZW5lcmF0ZVR5cGVEZWZpbml0aW9ucyhlbmRwb2ludCl9XG5cbiR7ZmV0Y2hGdW5jdGlvbn1cblxuZXhwb3J0IGZ1bmN0aW9uICR7ZnVuY3Rpb25OYW1lfShcbiAgJHt0aGlzLmdlbmVyYXRlSG9va1BhcmFtZXRlcnMoZW5kcG9pbnQpfSxcbiAgb3B0aW9ucz86IE9taXQ8VXNlUXVlcnlPcHRpb25zPCR7dGhpcy5nZXRSZXNwb25zZVR5cGUoZW5kcG9pbnQpfSwgRXJyb3I+LCAncXVlcnlLZXknIHwgJ3F1ZXJ5Rm4nPlxuKSB7XG4gIHJldHVybiB1c2VRdWVyeSh7XG4gICAgcXVlcnlLZXk6ICR7cXVlcnlLZXl9LFxuICAgIHF1ZXJ5Rm46ICgpID0+IGZldGNoJHt0aGlzLnRvUGFzY2FsQ2FzZShob29rTmFtZSl9KCR7dGhpcy5nZW5lcmF0ZUZldGNoUGFyYW1zKGVuZHBvaW50KX0pLFxuICAgIC4uLm9wdGlvbnMsXG4gIH0pO1xufVxuXG4vLyBVc2FnZSBleGFtcGxlOlxuLy8gY29uc3QgeyBkYXRhLCBpc0xvYWRpbmcsIGVycm9yLCByZWZldGNoIH0gPSAke2Z1bmN0aW9uTmFtZX0oKTtcbmA7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBSZWFjdCBRdWVyeSB1c2VNdXRhdGlvbiBob29rXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlTXV0YXRpb25Ib29rKGhvb2tOYW1lOiBzdHJpbmcsIGVuZHBvaW50OiBBUElFbmRwb2ludCwgY29ubmVjdGlvbjogQVBJQ29ubmVjdGlvbik6IHN0cmluZyB7XG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gdGhpcy50b0NhbWVsQ2FzZShob29rTmFtZSk7XG4gICAgY29uc3QgZmV0Y2hGdW5jdGlvbiA9IHRoaXMuZ2VuZXJhdGVGZXRjaEZ1bmN0aW9uKGVuZHBvaW50KTtcbiAgICBjb25zdCBoYXNPcHRpbWlzdGljID0gY29ubmVjdGlvbi5vcHRpbWlzdGljVXBkYXRlO1xuICAgIFxuICAgIHJldHVybiBgaW1wb3J0IHsgdXNlTXV0YXRpb24sIHVzZVF1ZXJ5Q2xpZW50LCBVc2VNdXRhdGlvbk9wdGlvbnMgfSBmcm9tICdAdGFuc3RhY2svcmVhY3QtcXVlcnknO1xuXG4ke3RoaXMuZ2VuZXJhdGVUeXBlRGVmaW5pdGlvbnMoZW5kcG9pbnQpfVxuXG4ke2ZldGNoRnVuY3Rpb259XG5cbmV4cG9ydCBmdW5jdGlvbiAke2Z1bmN0aW9uTmFtZX0oXG4gIG9wdGlvbnM/OiBVc2VNdXRhdGlvbk9wdGlvbnM8JHt0aGlzLmdldFJlc3BvbnNlVHlwZShlbmRwb2ludCl9LCBFcnJvciwgJHt0aGlzLmdldFJlcXVlc3RUeXBlKGVuZHBvaW50KX0+XG4pIHtcbiAgY29uc3QgcXVlcnlDbGllbnQgPSB1c2VRdWVyeUNsaWVudCgpO1xuXG4gIHJldHVybiB1c2VNdXRhdGlvbih7XG4gICAgbXV0YXRpb25GbjogZmV0Y2gke3RoaXMudG9QYXNjYWxDYXNlKGhvb2tOYW1lKX0sXG4gICAgJHtoYXNPcHRpbWlzdGljID8gdGhpcy5nZW5lcmF0ZU9wdGltaXN0aWNVcGRhdGUoZW5kcG9pbnQpIDogJyd9XG4gICAgb25TdWNjZXNzOiAoZGF0YSkgPT4ge1xuICAgICAgLy8gSW52YWxpZGF0ZSBhbmQgcmVmZXRjaCByZWxhdGVkIHF1ZXJpZXNcbiAgICAgIHF1ZXJ5Q2xpZW50LmludmFsaWRhdGVRdWVyaWVzKHsgcXVlcnlLZXk6IFsnJHt0aGlzLmdldFJlc291cmNlTmFtZShlbmRwb2ludCl9J10gfSk7XG4gICAgICAke2Nvbm5lY3Rpb24ub25TdWNjZXNzID8gYG9wdGlvbnM/Lm9uU3VjY2Vzcz8uKGRhdGEpO2AgOiAnJ31cbiAgICB9LFxuICAgIG9uRXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcignTXV0YXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgJHtjb25uZWN0aW9uLm9uRXJyb3IgPyBgb3B0aW9ucz8ub25FcnJvcj8uKGVycm9yKTtgIDogJyd9XG4gICAgfSxcbiAgICAuLi5vcHRpb25zLFxuICB9KTtcbn1cblxuLy8gVXNhZ2UgZXhhbXBsZTpcbi8vIGNvbnN0IG11dGF0aW9uID0gJHtmdW5jdGlvbk5hbWV9KCk7XG4vLyBtdXRhdGlvbi5tdXRhdGUoJHt0aGlzLmdldFJlcXVlc3RUeXBlKGVuZHBvaW50KSAhPT0gJ3ZvaWQnID8gJ3sgLyogZGF0YSAqLyB9JyA6ICcnfSk7XG5gO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGZldGNoIGZ1bmN0aW9uIGZvciBBUEkgZW5kcG9pbnRcbiAgICovXG4gIHByaXZhdGUgZ2VuZXJhdGVGZXRjaEZ1bmN0aW9uKGVuZHBvaW50OiBBUElFbmRwb2ludCk6IHN0cmluZyB7XG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gYGZldGNoJHt0aGlzLnRvUGFzY2FsQ2FzZShlbmRwb2ludC5pZCl9YDtcbiAgICBjb25zdCBoYXNSZXF1ZXN0Qm9keSA9IFsnUE9TVCcsICdQVVQnLCAnUEFUQ0gnXS5pbmNsdWRlcyhlbmRwb2ludC5tZXRob2QpO1xuICAgIGNvbnN0IHBhcmFtcyA9IGhhc1JlcXVlc3RCb2R5ID8gYGRhdGE6ICR7dGhpcy5nZXRSZXF1ZXN0VHlwZShlbmRwb2ludCl9YCA6IHRoaXMuZ2VuZXJhdGVQYXRoUGFyYW1zKGVuZHBvaW50KTtcbiAgICBcbiAgICByZXR1cm4gYGFzeW5jIGZ1bmN0aW9uICR7ZnVuY3Rpb25OYW1lfSgke3BhcmFtc30pOiBQcm9taXNlPCR7dGhpcy5nZXRSZXNwb25zZVR5cGUoZW5kcG9pbnQpfT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxcYFxcJHtwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICcnfSR7dGhpcy5pbnRlcnBvbGF0ZVBhdGgoZW5kcG9pbnQucGF0aCl9XFxgLCB7XG4gICAgbWV0aG9kOiAnJHtlbmRwb2ludC5tZXRob2R9JyxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgJHtlbmRwb2ludC5yZXF1aXJlc0F1dGggPyBgJ0F1dGhvcml6YXRpb24nOiBcXGBCZWFyZXIgXFwke2xvY2FsU3RvcmFnZS5nZXRJdGVtKCd0b2tlbicpfVxcYCxgIDogJyd9XG4gICAgfSxcbiAgICAke2hhc1JlcXVlc3RCb2R5ID8gJ2JvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLCcgOiAnJ31cbiAgfSk7XG5cbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIHRocm93IG5ldyBFcnJvcihcXGBBUEkgZXJyb3I6IFxcJHtyZXNwb25zZS5zdGF0dXN9IFxcJHtyZXNwb25zZS5zdGF0dXNUZXh0fVxcYCk7XG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xufVxuYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgZnJvbSBzY2hlbWFzXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlVHlwZURlZmluaXRpb25zKGVuZHBvaW50OiBBUElFbmRwb2ludCk6IHN0cmluZyB7XG4gICAgY29uc3QgdHlwZXM6IHN0cmluZ1tdID0gW107XG4gICAgXG4gICAgaWYgKGVuZHBvaW50LnJlcXVlc3RTY2hlbWEpIHtcbiAgICAgIHR5cGVzLnB1c2goYGV4cG9ydCBpbnRlcmZhY2UgJHt0aGlzLnRvUGFzY2FsQ2FzZShlbmRwb2ludC5pZCl9UmVxdWVzdCB7XG4gICR7dGhpcy5zY2hlbWFUb1R5cGVGaWVsZHMoZW5kcG9pbnQucmVxdWVzdFNjaGVtYSl9XG59YCk7XG4gICAgfVxuICAgIFxuICAgIGlmIChlbmRwb2ludC5yZXNwb25zZVNjaGVtYSkge1xuICAgICAgdHlwZXMucHVzaChgZXhwb3J0IGludGVyZmFjZSAke3RoaXMudG9QYXNjYWxDYXNlKGVuZHBvaW50LmlkKX1SZXNwb25zZSB7XG4gICR7dGhpcy5zY2hlbWFUb1R5cGVGaWVsZHMoZW5kcG9pbnQucmVzcG9uc2VTY2hlbWEpfVxufWApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gdHlwZXMuam9pbignXFxuXFxuJyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBzY2hlbWEgb2JqZWN0IHRvIFR5cGVTY3JpcHQgaW50ZXJmYWNlIGZpZWxkc1xuICAgKi9cbiAgcHJpdmF0ZSBzY2hlbWFUb1R5cGVGaWVsZHMoc2NoZW1hOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogc3RyaW5nIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoc2NoZW1hKVxuICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLmluZmVyVHlwZUZyb21TY2hlbWEodmFsdWUpO1xuICAgICAgICBjb25zdCBvcHRpb25hbCA9IHZhbHVlLm9wdGlvbmFsID8gJz8nIDogJyc7XG4gICAgICAgIHJldHVybiBgICAke2tleX0ke29wdGlvbmFsfTogJHt0eXBlfTtgO1xuICAgICAgfSlcbiAgICAgIC5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmZlciBUeXBlU2NyaXB0IHR5cGUgZnJvbSBzY2hlbWEgZGVmaW5pdGlvblxuICAgKi9cbiAgcHJpdmF0ZSBpbmZlclR5cGVGcm9tU2NoZW1hKHZhbHVlOiBhbnkpOiBzdHJpbmcge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdmFsdWU7IC8vIEFscmVhZHkgYSB0eXBlIHN0cmluZ1xuICAgIH1cbiAgICBcbiAgICBpZiAodmFsdWUudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgcmV0dXJuIGAke3RoaXMuaW5mZXJUeXBlRnJvbVNjaGVtYSh2YWx1ZS5pdGVtcyl9W11gO1xuICAgIH1cbiAgICBcbiAgICBpZiAodmFsdWUudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiAnUmVjb3JkPHN0cmluZywgYW55Pic7IC8vIFNpbXBsaWZpZWQgZm9yIG5vd1xuICAgIH1cbiAgICBcbiAgICBjb25zdCB0eXBlTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICAgc3RyaW5nOiAnc3RyaW5nJyxcbiAgICAgIG51bWJlcjogJ251bWJlcicsXG4gICAgICBib29sZWFuOiAnYm9vbGVhbicsXG4gICAgICBkYXRlOiAnRGF0ZScsXG4gICAgICBhbnk6ICdhbnknLFxuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHR5cGVNYXBbdmFsdWUudHlwZV0gfHwgJ2FueSc7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgcXVlcnkga2V5IGZvciBSZWFjdCBRdWVyeVxuICAgKi9cbiAgcHJpdmF0ZSBnZW5lcmF0ZVF1ZXJ5S2V5KGVuZHBvaW50OiBBUElFbmRwb2ludCk6IHN0cmluZyB7XG4gICAgY29uc3QgcmVzb3VyY2VOYW1lID0gdGhpcy5nZXRSZXNvdXJjZU5hbWUoZW5kcG9pbnQpO1xuICAgIGNvbnN0IHBhdGhQYXJhbXMgPSB0aGlzLmV4dHJhY3RQYXRoUGFyYW1zKGVuZHBvaW50LnBhdGgpO1xuICAgIFxuICAgIGlmIChwYXRoUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBgWycke3Jlc291cmNlTmFtZX0nLCAke3BhdGhQYXJhbXMuam9pbignLCAnKX1dYDtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGBbJyR7cmVzb3VyY2VOYW1lfSddYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IHJlc291cmNlIG5hbWUgZnJvbSBlbmRwb2ludCBwYXRoXG4gICAqL1xuICBwcml2YXRlIGdldFJlc291cmNlTmFtZShlbmRwb2ludDogQVBJRW5kcG9pbnQpOiBzdHJpbmcge1xuICAgIC8vIEV4dHJhY3QgZmlyc3Qgbm9uLWFwaSBwYXRoIHNlZ21lbnQgYXMgcmVzb3VyY2UgbmFtZVxuICAgIGNvbnN0IG1hdGNoID0gZW5kcG9pbnQucGF0aC5tYXRjaCgvXlxcLyg/OmFwaVxcLyk/KFteXFwvXSspLyk7XG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAncmVzb3VyY2UnO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgcGF0aCBwYXJhbWV0ZXJzIGZyb20gZW5kcG9pbnQgcGF0aFxuICAgKi9cbiAgcHJpdmF0ZSBleHRyYWN0UGF0aFBhcmFtcyhwYXRoOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHBhdGgubWF0Y2goLzooXFx3KykvZyk7XG4gICAgcmV0dXJuIG1hdGNoZXMgPyBtYXRjaGVzLm1hcChtID0+IG0uc3Vic3RyaW5nKDEpKSA6IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIHBhdGggcGFyYW1ldGVycyBmb3IgZnVuY3Rpb24gc2lnbmF0dXJlXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlUGF0aFBhcmFtcyhlbmRwb2ludDogQVBJRW5kcG9pbnQpOiBzdHJpbmcge1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuZXh0cmFjdFBhdGhQYXJhbXMoZW5kcG9pbnQucGF0aCk7XG4gICAgcmV0dXJuIHBhcmFtcy5tYXAocCA9PiBgJHtwfTogc3RyaW5nIHwgbnVtYmVyYCkuam9pbignLCAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcnBvbGF0ZSBwYXRoIHBhcmFtZXRlcnMgaW4gZW5kcG9pbnQgcGF0aFxuICAgKi9cbiAgcHJpdmF0ZSBpbnRlcnBvbGF0ZVBhdGgocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC86KFxcdyspL2csICckeyQxfScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGZldGNoIGZ1bmN0aW9uIHBhcmFtZXRlcnNcbiAgICovXG4gIHByaXZhdGUgZ2VuZXJhdGVGZXRjaFBhcmFtcyhlbmRwb2ludDogQVBJRW5kcG9pbnQpOiBzdHJpbmcge1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuZXh0cmFjdFBhdGhQYXJhbXMoZW5kcG9pbnQucGF0aCk7XG4gICAgcmV0dXJuIHBhcmFtcy5qb2luKCcsICcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGhvb2sgcGFyYW1ldGVyc1xuICAgKi9cbiAgcHJpdmF0ZSBnZW5lcmF0ZUhvb2tQYXJhbWV0ZXJzKGVuZHBvaW50OiBBUElFbmRwb2ludCk6IHN0cmluZyB7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5leHRyYWN0UGF0aFBhcmFtcyhlbmRwb2ludC5wYXRoKTtcbiAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIHJldHVybiBwYXJhbXMubWFwKHAgPT4gYCR7cH06IHN0cmluZyB8IG51bWJlcmApLmpvaW4oJywgJyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHJlcXVlc3QgdHlwZSBuYW1lXG4gICAqL1xuICBwcml2YXRlIGdldFJlcXVlc3RUeXBlKGVuZHBvaW50OiBBUElFbmRwb2ludCk6IHN0cmluZyB7XG4gICAgaWYgKCFlbmRwb2ludC5yZXF1ZXN0U2NoZW1hKSByZXR1cm4gJ3ZvaWQnO1xuICAgIHJldHVybiBgJHt0aGlzLnRvUGFzY2FsQ2FzZShlbmRwb2ludC5pZCl9UmVxdWVzdGA7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHJlc3BvbnNlIHR5cGUgbmFtZVxuICAgKi9cbiAgcHJpdmF0ZSBnZXRSZXNwb25zZVR5cGUoZW5kcG9pbnQ6IEFQSUVuZHBvaW50KTogc3RyaW5nIHtcbiAgICBpZiAoIWVuZHBvaW50LnJlc3BvbnNlU2NoZW1hKSByZXR1cm4gJ2FueSc7XG4gICAgcmV0dXJuIGAke3RoaXMudG9QYXNjYWxDYXNlKGVuZHBvaW50LmlkKX1SZXNwb25zZWA7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgb3B0aW1pc3RpYyB1cGRhdGUgbG9naWNcbiAgICovXG4gIHByaXZhdGUgZ2VuZXJhdGVPcHRpbWlzdGljVXBkYXRlKGVuZHBvaW50OiBBUElFbmRwb2ludCk6IHN0cmluZyB7XG4gICAgY29uc3QgcmVzb3VyY2VOYW1lID0gdGhpcy5nZXRSZXNvdXJjZU5hbWUoZW5kcG9pbnQpO1xuICAgIFxuICAgIHJldHVybiBgb25NdXRhdGU6IGFzeW5jIChuZXdEYXRhKSA9PiB7XG4gICAgICAvLyBDYW5jZWwgb3V0Z29pbmcgcmVmZXRjaGVzXG4gICAgICBhd2FpdCBxdWVyeUNsaWVudC5jYW5jZWxRdWVyaWVzKHsgcXVlcnlLZXk6IFsnJHtyZXNvdXJjZU5hbWV9J10gfSk7XG5cbiAgICAgIC8vIFNuYXBzaG90IHByZXZpb3VzIHZhbHVlXG4gICAgICBjb25zdCBwcmV2aW91c0RhdGEgPSBxdWVyeUNsaWVudC5nZXRRdWVyeURhdGEoWycke3Jlc291cmNlTmFtZX0nXSk7XG5cbiAgICAgIC8vIE9wdGltaXN0aWNhbGx5IHVwZGF0ZVxuICAgICAgcXVlcnlDbGllbnQuc2V0UXVlcnlEYXRhKFsnJHtyZXNvdXJjZU5hbWV9J10sIChvbGQ6IGFueSkgPT4ge1xuICAgICAgICAvLyBJbXBsZW1lbnQgb3B0aW1pc3RpYyB1cGRhdGUgbG9naWMgYmFzZWQgb24geW91ciBkYXRhIHN0cnVjdHVyZVxuICAgICAgICByZXR1cm4gbmV3RGF0YTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZXR1cm4gY29udGV4dCB3aXRoIHNuYXBzaG90XG4gICAgICByZXR1cm4geyBwcmV2aW91c0RhdGEgfTtcbiAgICB9LFxuICAgIG9uRXJyb3I6IChlcnIsIG5ld0RhdGEsIGNvbnRleHQpID0+IHtcbiAgICAgIC8vIFJvbGxiYWNrIG9uIGVycm9yXG4gICAgICBpZiAoY29udGV4dD8ucHJldmlvdXNEYXRhKSB7XG4gICAgICAgIHF1ZXJ5Q2xpZW50LnNldFF1ZXJ5RGF0YShbJyR7cmVzb3VyY2VOYW1lfSddLCBjb250ZXh0LnByZXZpb3VzRGF0YSk7XG4gICAgICB9XG4gICAgfSxgO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGNvbXBvbmVudCB3aXRoIEFQSSBjb25uZWN0aW9uXG4gICAqL1xuICBnZW5lcmF0ZUNvbm5lY3RlZENvbXBvbmVudChcbiAgICBjb21wb25lbnRJZDogc3RyaW5nLFxuICAgIGVuZHBvaW50OiBBUElFbmRwb2ludCxcbiAgICBjb25uZWN0aW9uOiBBUElDb25uZWN0aW9uLFxuICAgIG91dHB1dERpcjogc3RyaW5nXG4gICk6IEZpbGVDaGFuZ2VbXSB7XG4gICAgY29uc3QgY2hhbmdlczogRmlsZUNoYW5nZVtdID0gW107XG4gICAgY29uc3QgY29tcG9uZW50UGF0aCA9IHBhdGguam9pbihvdXRwdXREaXIsICdjb21wb25lbnRzJywgYCR7dGhpcy50b0tlYmFiQ2FzZShjb21wb25lbnRJZCl9LnRzeGApO1xuICAgIGNvbnN0IGhvb2tOYW1lID0gYHVzZSR7dGhpcy50b1Bhc2NhbENhc2UoZW5kcG9pbnQuaWQpfWA7XG4gICAgXG4gICAgLy8gR2VuZXJhdGUgdGhlIGhvb2sgZmlyc3RcbiAgICBjaGFuZ2VzLnB1c2goLi4udGhpcy5nZW5lcmF0ZVJlYWN0UXVlcnlIb29rKHtcbiAgICAgIGhvb2tOYW1lLFxuICAgICAgZW5kcG9pbnQsXG4gICAgICBjb25uZWN0aW9uLFxuICAgIH0sIG91dHB1dERpcikpO1xuICAgIFxuICAgIC8vIEdlbmVyYXRlIGNvbXBvbmVudCB0aGF0IHVzZXMgdGhlIGhvb2tcbiAgICBjaGFuZ2VzLnB1c2goe1xuICAgICAgcGF0aDogY29tcG9uZW50UGF0aCxcbiAgICAgIHR5cGU6ICdjcmVhdGUnLFxuICAgICAgY29udGVudDogdGhpcy5nZW5lcmF0ZUNvbXBvbmVudFdpdGhIb29rKGNvbXBvbmVudElkLCBob29rTmFtZSwgY29ubmVjdGlvbiksXG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIGNoYW5nZXM7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgY29tcG9uZW50IGNvZGUgdGhhdCB1c2VzIHRoZSBBUEkgaG9va1xuICAgKi9cbiAgcHJpdmF0ZSBnZW5lcmF0ZUNvbXBvbmVudFdpdGhIb29rKGNvbXBvbmVudElkOiBzdHJpbmcsIGhvb2tOYW1lOiBzdHJpbmcsIGNvbm5lY3Rpb246IEFQSUNvbm5lY3Rpb24pOiBzdHJpbmcge1xuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSB0aGlzLnRvUGFzY2FsQ2FzZShjb21wb25lbnRJZCk7XG4gICAgY29uc3QgaXNRdWVyeSA9IGNvbm5lY3Rpb24ub3BlcmF0aW9uID09PSAncXVlcnknO1xuICAgIFxuICAgIGlmIChpc1F1ZXJ5KSB7XG4gICAgICByZXR1cm4gYCd1c2UgY2xpZW50JztcblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7ICR7dGhpcy50b0NhbWVsQ2FzZShob29rTmFtZSl9IH0gZnJvbSAnQC9ob29rcy8ke3RoaXMudG9LZWJhYkNhc2UoaG9va05hbWUpfSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICR7Y29tcG9uZW50TmFtZX0oKSB7XG4gIGNvbnN0IHsgZGF0YSwgaXNMb2FkaW5nLCBlcnJvciwgcmVmZXRjaCB9ID0gJHt0aGlzLnRvQ2FtZWxDYXNlKGhvb2tOYW1lKX0oKTtcblxuICBpZiAoaXNMb2FkaW5nKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgcC04XCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYW5pbWF0ZS1zcGluIHJvdW5kZWQtZnVsbCBoLTggdy04IGJvcmRlci1iLTIgYm9yZGVyLWJsdWUtNjAwXCI+PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgaWYgKGVycm9yKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmctcmVkLTUwIGJvcmRlciBib3JkZXItcmVkLTIwMCByb3VuZGVkLW1kIHAtNFwiPlxuICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXJlZC04MDBcIj5FcnJvcjoge2Vycm9yLm1lc3NhZ2V9PC9wPlxuICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHJlZmV0Y2goKX1cbiAgICAgICAgICBjbGFzc05hbWU9XCJtdC0yIHB4LTQgcHktMiBiZy1yZWQtNjAwIHRleHQtd2hpdGUgcm91bmRlZC1tZCBob3ZlcjpiZy1yZWQtNzAwXCJcbiAgICAgICAgPlxuICAgICAgICAgIFJldHJ5XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJwLTRcIj5cbiAgICAgIHsvKiBSZW5kZXIgeW91ciBkYXRhIGhlcmUgKi99XG4gICAgICA8cHJlIGNsYXNzTmFtZT1cImJnLWdyYXktMTAwIHAtNCByb3VuZGVkLW1kIG92ZXJmbG93LWF1dG9cIj5cbiAgICAgICAge0pTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpfVxuICAgICAgPC9wcmU+XG4gICAgPC9kaXY+XG4gICk7XG59XG5gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYCd1c2UgY2xpZW50JztcblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7ICR7dGhpcy50b0NhbWVsQ2FzZShob29rTmFtZSl9IH0gZnJvbSAnQC9ob29rcy8ke3RoaXMudG9LZWJhYkNhc2UoaG9va05hbWUpfSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICR7Y29tcG9uZW50TmFtZX0oKSB7XG4gIGNvbnN0IG11dGF0aW9uID0gJHt0aGlzLnRvQ2FtZWxDYXNlKGhvb2tOYW1lKX0oKTtcblxuICBjb25zdCBoYW5kbGVTdWJtaXQgPSBhc3luYyAoZTogUmVhY3QuRm9ybUV2ZW50KSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vIENvbGxlY3QgZm9ybSBkYXRhIGFuZCBjYWxsIG11dGF0aW9uXG4gICAgbXV0YXRpb24ubXV0YXRlKHtcbiAgICAgIC8vIEFkZCB5b3VyIGRhdGEgaGVyZVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJwLTRcIj5cbiAgICAgIDxmb3JtIG9uU3VibWl0PXtoYW5kbGVTdWJtaXR9IGNsYXNzTmFtZT1cInNwYWNlLXktNFwiPlxuICAgICAgICB7LyogQWRkIHlvdXIgZm9ybSBmaWVsZHMgaGVyZSAqL31cbiAgICAgICAgXG4gICAgICAgIDxidXR0b24gXG4gICAgICAgICAgdHlwZT1cInN1Ym1pdFwiXG4gICAgICAgICAgZGlzYWJsZWQ9e211dGF0aW9uLmlzUGVuZGluZ31cbiAgICAgICAgICBjbGFzc05hbWU9XCJweC00IHB5LTIgYmctYmx1ZS02MDAgdGV4dC13aGl0ZSByb3VuZGVkLW1kIGhvdmVyOmJnLWJsdWUtNzAwIGRpc2FibGVkOm9wYWNpdHktNTBcIlxuICAgICAgICA+XG4gICAgICAgICAge211dGF0aW9uLmlzUGVuZGluZyA/ICdTdWJtaXR0aW5nLi4uJyA6ICdTdWJtaXQnfVxuICAgICAgICA8L2J1dHRvbj5cblxuICAgICAgICB7bXV0YXRpb24uaXNFcnJvciAmJiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJiZy1yZWQtNTAgYm9yZGVyIGJvcmRlci1yZWQtMjAwIHJvdW5kZWQtbWQgcC00XCI+XG4gICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXJlZC04MDBcIj5FcnJvcjoge211dGF0aW9uLmVycm9yLm1lc3NhZ2V9PC9wPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuXG4gICAgICAgIHttdXRhdGlvbi5pc1N1Y2Nlc3MgJiYgKFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmctZ3JlZW4tNTAgYm9yZGVyIGJvcmRlci1ncmVlbi0yMDAgcm91bmRlZC1tZCBwLTRcIj5cbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtZ3JlZW4tODAwXCI+U3VjY2VzcyE8L3A+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgICA8L2Zvcm0+XG4gICAgPC9kaXY+XG4gICk7XG59XG5gO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHN0cmluZyB0byBQYXNjYWxDYXNlXG4gICAqL1xuICBwcml2YXRlIHRvUGFzY2FsQ2FzZShzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLV9cXHM6XSsoLik/L2csIChfLCBjKSA9PiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJycpXG4gICAgICAucmVwbGFjZSgvXlthLXpdLywgYyA9PiBjLnRvVXBwZXJDYXNlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgc3RyaW5nIHRvIGNhbWVsQ2FzZVxuICAgKi9cbiAgcHJpdmF0ZSB0b0NhbWVsQ2FzZShzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgcGFzY2FsID0gdGhpcy50b1Bhc2NhbENhc2Uoc3RyKTtcbiAgICByZXR1cm4gcGFzY2FsLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgcGFzY2FsLnNsaWNlKDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgc3RyaW5nIHRvIGtlYmFiLWNhc2VcbiAgICovXG4gIHByaXZhdGUgdG9LZWJhYkNhc2Uoc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBzdHJcbiAgICAgIC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKVxuICAgICAgLnJlcGxhY2UoL1tcXHNfOl0rL2csICctJylcbiAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBLElBQUFBLElBQUEsR0FBQUMsdUJBQUEsQ0FBQUMsT0FBQTtBQUE2QixTQUFBRCx3QkFBQUUsQ0FBQSxFQUFBQyxDQUFBLDZCQUFBQyxPQUFBLE1BQUFDLENBQUEsT0FBQUQsT0FBQSxJQUFBRSxDQUFBLE9BQUFGLE9BQUEsWUFBQUosdUJBQUEsWUFBQUEsQ0FBQUUsQ0FBQSxFQUFBQyxDQUFBLFNBQUFBLENBQUEsSUFBQUQsQ0FBQSxJQUFBQSxDQUFBLENBQUFLLFVBQUEsU0FBQUwsQ0FBQSxNQUFBTSxDQUFBLEVBQUFDLENBQUEsRUFBQUMsQ0FBQSxLQUFBQyxTQUFBLFFBQUFDLE9BQUEsRUFBQVYsQ0FBQSxpQkFBQUEsQ0FBQSx1QkFBQUEsQ0FBQSx5QkFBQUEsQ0FBQSxTQUFBUSxDQUFBLE1BQUFGLENBQUEsR0FBQUwsQ0FBQSxHQUFBRyxDQUFBLEdBQUFELENBQUEsUUFBQUcsQ0FBQSxDQUFBSyxHQUFBLENBQUFYLENB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