0181c28d6f6631df619798910d5e66a8
"use strict";

// Mock fs and glob
_getJestObj().mock('fs');
_getJestObj().mock('glob');
var _ComponentStyleRefactor = require("../ComponentStyleRefactor");
var fs = _interopRequireWildcard(require("fs"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
function _getJestObj() {
  const {
    jest
  } = require("@jest/globals");
  _getJestObj = () => jest;
  return jest;
}
describe('ComponentStyleRefactor', () => {
  let refactor;
  const mockProjectRoot = '/mock/project';
  beforeEach(() => {
    refactor = new _ComponentStyleRefactor.ComponentStyleRefactor(mockProjectRoot);
    jest.clearAllMocks();
  });
  describe('identifyComponentsWithOldStyles', () => {
    it('should identify components with old Tailwind classes', async () => {
      const classMapping = {
        'bg-blue-500': 'bg-primary-500',
        'text-gray-900': 'text-neutral-900'
      };
      const mockComponent = `
        import React from 'react';
        
        export const Button = () => {
          return <button className="bg-blue-500 text-gray-900">Click me</button>;
        };
      `;

      // Mock glob to return test files
      const {
        glob
      } = require('glob');
      glob.mockResolvedValue(['/mock/project/Button.tsx']);

      // Mock fs.promises.readFile
      fs.promises.readFile.mockResolvedValue(mockComponent);
      const components = await refactor.identifyComponentsWithOldStyles(classMapping);
      expect(components.length).toBeGreaterThan(0);
      expect(components[0].classNames).toContain('bg-blue-500');
      expect(components[0].classNames).toContain('text-gray-900');
    });
  });
  describe('applyTailwindTransformations', () => {
    it('should transform className attributes', async () => {
      const classMapping = {
        'bg-blue-500': 'bg-primary-500',
        'text-gray-900': 'text-neutral-900'
      };
      const mockComponent = {
        filePath: '/mock/project/Button.tsx',
        componentName: 'Button',
        hasInlineStyles: false,
        hasCSSModule: false,
        hasCustomOverrides: false,
        classNames: ['bg-blue-500', 'text-gray-900'],
        inlineStyles: [],
        cssModuleClasses: []
      };
      const mockContent = `
        import React from 'react';
        
        export const Button = () => {
          return <button className="bg-blue-500 text-gray-900">Click me</button>;
        };
      `;
      fs.promises.readFile.mockResolvedValue(mockContent);
      const changes = await refactor.applyTailwindTransformations([mockComponent], classMapping);
      expect(changes.length).toBe(1);
      expect(changes[0].content).toContain('bg-primary-500');
      expect(changes[0].content).toContain('text-neutral-900');
      expect(changes[0].content).not.toContain('bg-blue-500');
    });
    it('should convert inline styles to Tailwind classes', async () => {
      const classMapping = {};
      const mockComponent = {
        filePath: '/mock/project/Card.tsx',
        componentName: 'Card',
        hasInlineStyles: true,
        hasCSSModule: false,
        hasCustomOverrides: false,
        classNames: [],
        inlineStyles: [{
          line: 5,
          property: 'display',
          value: 'flex',
          context: 'style={{display: "flex"}}'
        }],
        cssModuleClasses: []
      };
      const mockContent = `
        import React from 'react';
        
        export const Card = () => {
          return <div style={{display: 'flex'}}>Content</div>;
        };
      `;
      fs.promises.readFile.mockResolvedValue(mockContent);
      const changes = await refactor.applyTailwindTransformations([mockComponent], classMapping);
      expect(changes.length).toBe(1);
      expect(changes[0].content).toContain('className="flex"');
    });
    it('should preserve custom overrides', async () => {
      const classMapping = {
        'bg-blue-500': 'bg-primary-500'
      };
      const mockComponent = {
        filePath: '/mock/project/Custom.tsx',
        componentName: 'Custom',
        hasInlineStyles: false,
        hasCSSModule: false,
        hasCustomOverrides: true,
        classNames: ['bg-blue-500'],
        inlineStyles: [],
        cssModuleClasses: []
      };
      const mockContent = `
        import React from 'react';
        
        export const Custom = () => {
          return (
            <div>
              {/* custom */}
              <button className="bg-blue-500">Original</button>
            </div>
          );
        };
      `;
      fs.promises.readFile.mockResolvedValue(mockContent);
      const changes = await refactor.applyTailwindTransformations([mockComponent], classMapping);
      expect(changes.length).toBe(1);
      // Custom override line should be preserved
      expect(changes[0].content).toContain('/* custom */');
    });
  });
  describe('refactorComponents', () => {
    it('should return refactor statistics', async () => {
      const classMapping = {
        'bg-blue-500': 'bg-primary-500'
      };
      const {
        glob
      } = require('glob');
      glob.mockResolvedValue(['/mock/project/Button.tsx']);
      const mockContent = `
        import React from 'react';
        export const Button = () => <button className="bg-blue-500">Click</button>;
      `;
      fs.promises.readFile.mockResolvedValue(mockContent);
      const result = await refactor.refactorComponents(classMapping);
      expect(result.filesProcessed).toBeGreaterThanOrEqual(0);
      expect(result.changes).toBeDefined();
      expect(Array.isArray(result.changes)).toBe(true);
    });
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfZ2V0SmVzdE9iaiIsIm1vY2siLCJfQ29tcG9uZW50U3R5bGVSZWZhY3RvciIsInJlcXVpcmUiLCJmcyIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwiZSIsInQiLCJXZWFrTWFwIiwiciIsIm4iLCJfX2VzTW9kdWxlIiwibyIsImkiLCJmIiwiX19wcm90b19fIiwiZGVmYXVsdCIsImhhcyIsImdldCIsInNldCIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiamVzdCIsImRlc2NyaWJlIiwicmVmYWN0b3IiLCJtb2NrUHJvamVjdFJvb3QiLCJiZWZvcmVFYWNoIiwiQ29tcG9uZW50U3R5bGVSZWZhY3RvciIsImNsZWFyQWxsTW9ja3MiLCJpdCIsImNsYXNzTWFwcGluZyIsIm1vY2tDb21wb25lbnQiLCJnbG9iIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJwcm9taXNlcyIsInJlYWRGaWxlIiwiY29tcG9uZW50cyIsImlkZW50aWZ5Q29tcG9uZW50c1dpdGhPbGRTdHlsZXMiLCJleHBlY3QiLCJsZW5ndGgiLCJ0b0JlR3JlYXRlclRoYW4iLCJjbGFzc05hbWVzIiwidG9Db250YWluIiwiZmlsZVBhdGgiLCJjb21wb25lbnROYW1lIiwiaGFzSW5saW5lU3R5bGVzIiwiaGFzQ1NTTW9kdWxlIiwiaGFzQ3VzdG9tT3ZlcnJpZGVzIiwiaW5saW5lU3R5bGVzIiwiY3NzTW9kdWxlQ2xhc3NlcyIsIm1vY2tDb250ZW50IiwiY2hhbmdlcyIsImFwcGx5VGFpbHdpbmRUcmFuc2Zvcm1hdGlvbnMiLCJ0b0JlIiwiY29udGVudCIsIm5vdCIsImxpbmUiLCJwcm9wZXJ0eSIsInZhbHVlIiwiY29udGV4dCIsInJlc3VsdCIsInJlZmFjdG9yQ29tcG9uZW50cyIsImZpbGVzUHJvY2Vzc2VkIiwidG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCIsInRvQmVEZWZpbmVkIiwiQXJyYXkiLCJpc0FycmF5Il0sInNvdXJjZXMiOlsiQ29tcG9uZW50U3R5bGVSZWZhY3Rvci50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudFN0eWxlUmVmYWN0b3IgfSBmcm9tICcuLi9Db21wb25lbnRTdHlsZVJlZmFjdG9yJztcbmltcG9ydCB7IENsYXNzTWFwcGluZyB9IGZyb20gJy4uL0Rlc2lnbkZpbHRlckVuZ2luZSc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuXG4vLyBNb2NrIGZzIGFuZCBnbG9iXG5qZXN0Lm1vY2soJ2ZzJyk7XG5qZXN0Lm1vY2soJ2dsb2InKTtcblxuZGVzY3JpYmUoJ0NvbXBvbmVudFN0eWxlUmVmYWN0b3InLCAoKSA9PiB7XG4gIGxldCByZWZhY3RvcjogQ29tcG9uZW50U3R5bGVSZWZhY3RvcjtcbiAgY29uc3QgbW9ja1Byb2plY3RSb290ID0gJy9tb2NrL3Byb2plY3QnO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIHJlZmFjdG9yID0gbmV3IENvbXBvbmVudFN0eWxlUmVmYWN0b3IobW9ja1Byb2plY3RSb290KTtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2lkZW50aWZ5Q29tcG9uZW50c1dpdGhPbGRTdHlsZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBpZGVudGlmeSBjb21wb25lbnRzIHdpdGggb2xkIFRhaWx3aW5kIGNsYXNzZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjbGFzc01hcHBpbmc6IENsYXNzTWFwcGluZyA9IHtcbiAgICAgICAgJ2JnLWJsdWUtNTAwJzogJ2JnLXByaW1hcnktNTAwJyxcbiAgICAgICAgJ3RleHQtZ3JheS05MDAnOiAndGV4dC1uZXV0cmFsLTkwMCcsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrQ29tcG9uZW50ID0gYFxuICAgICAgICBpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuICAgICAgICBcbiAgICAgICAgZXhwb3J0IGNvbnN0IEJ1dHRvbiA9ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gPGJ1dHRvbiBjbGFzc05hbWU9XCJiZy1ibHVlLTUwMCB0ZXh0LWdyYXktOTAwXCI+Q2xpY2sgbWU8L2J1dHRvbj47XG4gICAgICAgIH07XG4gICAgICBgO1xuXG4gICAgICAvLyBNb2NrIGdsb2IgdG8gcmV0dXJuIHRlc3QgZmlsZXNcbiAgICAgIGNvbnN0IHsgZ2xvYiB9ID0gcmVxdWlyZSgnZ2xvYicpO1xuICAgICAgZ2xvYi5tb2NrUmVzb2x2ZWRWYWx1ZShbJy9tb2NrL3Byb2plY3QvQnV0dG9uLnRzeCddKTtcblxuICAgICAgLy8gTW9jayBmcy5wcm9taXNlcy5yZWFkRmlsZVxuICAgICAgKGZzLnByb21pc2VzLnJlYWRGaWxlIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUobW9ja0NvbXBvbmVudCk7XG5cbiAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBhd2FpdCByZWZhY3Rvci5pZGVudGlmeUNvbXBvbmVudHNXaXRoT2xkU3R5bGVzKGNsYXNzTWFwcGluZyk7XG5cbiAgICAgIGV4cGVjdChjb21wb25lbnRzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgZXhwZWN0KGNvbXBvbmVudHNbMF0uY2xhc3NOYW1lcykudG9Db250YWluKCdiZy1ibHVlLTUwMCcpO1xuICAgICAgZXhwZWN0KGNvbXBvbmVudHNbMF0uY2xhc3NOYW1lcykudG9Db250YWluKCd0ZXh0LWdyYXktOTAwJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdhcHBseVRhaWx3aW5kVHJhbnNmb3JtYXRpb25zJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgdHJhbnNmb3JtIGNsYXNzTmFtZSBhdHRyaWJ1dGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY2xhc3NNYXBwaW5nOiBDbGFzc01hcHBpbmcgPSB7XG4gICAgICAgICdiZy1ibHVlLTUwMCc6ICdiZy1wcmltYXJ5LTUwMCcsXG4gICAgICAgICd0ZXh0LWdyYXktOTAwJzogJ3RleHQtbmV1dHJhbC05MDAnLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja0NvbXBvbmVudCA9IHtcbiAgICAgICAgZmlsZVBhdGg6ICcvbW9jay9wcm9qZWN0L0J1dHRvbi50c3gnLFxuICAgICAgICBjb21wb25lbnROYW1lOiAnQnV0dG9uJyxcbiAgICAgICAgaGFzSW5saW5lU3R5bGVzOiBmYWxzZSxcbiAgICAgICAgaGFzQ1NTTW9kdWxlOiBmYWxzZSxcbiAgICAgICAgaGFzQ3VzdG9tT3ZlcnJpZGVzOiBmYWxzZSxcbiAgICAgICAgY2xhc3NOYW1lczogWydiZy1ibHVlLTUwMCcsICd0ZXh0LWdyYXktOTAwJ10sXG4gICAgICAgIGlubGluZVN0eWxlczogW10sXG4gICAgICAgIGNzc01vZHVsZUNsYXNzZXM6IFtdLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja0NvbnRlbnQgPSBgXG4gICAgICAgIGltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG4gICAgICAgIFxuICAgICAgICBleHBvcnQgY29uc3QgQnV0dG9uID0gKCkgPT4ge1xuICAgICAgICAgIHJldHVybiA8YnV0dG9uIGNsYXNzTmFtZT1cImJnLWJsdWUtNTAwIHRleHQtZ3JheS05MDBcIj5DbGljayBtZTwvYnV0dG9uPjtcbiAgICAgICAgfTtcbiAgICAgIGA7XG5cbiAgICAgIChmcy5wcm9taXNlcy5yZWFkRmlsZSBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tDb250ZW50KTtcblxuICAgICAgY29uc3QgY2hhbmdlcyA9IGF3YWl0IHJlZmFjdG9yLmFwcGx5VGFpbHdpbmRUcmFuc2Zvcm1hdGlvbnMoW21vY2tDb21wb25lbnRdLCBjbGFzc01hcHBpbmcpO1xuXG4gICAgICBleHBlY3QoY2hhbmdlcy5sZW5ndGgpLnRvQmUoMSk7XG4gICAgICBleHBlY3QoY2hhbmdlc1swXS5jb250ZW50KS50b0NvbnRhaW4oJ2JnLXByaW1hcnktNTAwJyk7XG4gICAgICBleHBlY3QoY2hhbmdlc1swXS5jb250ZW50KS50b0NvbnRhaW4oJ3RleHQtbmV1dHJhbC05MDAnKTtcbiAgICAgIGV4cGVjdChjaGFuZ2VzWzBdLmNvbnRlbnQpLm5vdC50b0NvbnRhaW4oJ2JnLWJsdWUtNTAwJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNvbnZlcnQgaW5saW5lIHN0eWxlcyB0byBUYWlsd2luZCBjbGFzc2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY2xhc3NNYXBwaW5nOiBDbGFzc01hcHBpbmcgPSB7fTtcblxuICAgICAgY29uc3QgbW9ja0NvbXBvbmVudCA9IHtcbiAgICAgICAgZmlsZVBhdGg6ICcvbW9jay9wcm9qZWN0L0NhcmQudHN4JyxcbiAgICAgICAgY29tcG9uZW50TmFtZTogJ0NhcmQnLFxuICAgICAgICBoYXNJbmxpbmVTdHlsZXM6IHRydWUsXG4gICAgICAgIGhhc0NTU01vZHVsZTogZmFsc2UsXG4gICAgICAgIGhhc0N1c3RvbU92ZXJyaWRlczogZmFsc2UsXG4gICAgICAgIGNsYXNzTmFtZXM6IFtdLFxuICAgICAgICBpbmxpbmVTdHlsZXM6IFtcbiAgICAgICAgICB7IGxpbmU6IDUsIHByb3BlcnR5OiAnZGlzcGxheScsIHZhbHVlOiAnZmxleCcsIGNvbnRleHQ6ICdzdHlsZT17e2Rpc3BsYXk6IFwiZmxleFwifX0nIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGNzc01vZHVsZUNsYXNzZXM6IFtdLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja0NvbnRlbnQgPSBgXG4gICAgICAgIGltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG4gICAgICAgIFxuICAgICAgICBleHBvcnQgY29uc3QgQ2FyZCA9ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gPGRpdiBzdHlsZT17e2Rpc3BsYXk6ICdmbGV4J319PkNvbnRlbnQ8L2Rpdj47XG4gICAgICAgIH07XG4gICAgICBgO1xuXG4gICAgICAoZnMucHJvbWlzZXMucmVhZEZpbGUgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrQ29udGVudCk7XG5cbiAgICAgIGNvbnN0IGNoYW5nZXMgPSBhd2FpdCByZWZhY3Rvci5hcHBseVRhaWx3aW5kVHJhbnNmb3JtYXRpb25zKFttb2NrQ29tcG9uZW50XSwgY2xhc3NNYXBwaW5nKTtcblxuICAgICAgZXhwZWN0KGNoYW5nZXMubGVuZ3RoKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KGNoYW5nZXNbMF0uY29udGVudCkudG9Db250YWluKCdjbGFzc05hbWU9XCJmbGV4XCInKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcHJlc2VydmUgY3VzdG9tIG92ZXJyaWRlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNsYXNzTWFwcGluZzogQ2xhc3NNYXBwaW5nID0ge1xuICAgICAgICAnYmctYmx1ZS01MDAnOiAnYmctcHJpbWFyeS01MDAnLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja0NvbXBvbmVudCA9IHtcbiAgICAgICAgZmlsZVBhdGg6ICcvbW9jay9wcm9qZWN0L0N1c3RvbS50c3gnLFxuICAgICAgICBjb21wb25lbnROYW1lOiAnQ3VzdG9tJyxcbiAgICAgICAgaGFzSW5saW5lU3R5bGVzOiBmYWxzZSxcbiAgICAgICAgaGFzQ1NTTW9kdWxlOiBmYWxzZSxcbiAgICAgICAgaGFzQ3VzdG9tT3ZlcnJpZGVzOiB0cnVlLFxuICAgICAgICBjbGFzc05hbWVzOiBbJ2JnLWJsdWUtNTAwJ10sXG4gICAgICAgIGlubGluZVN0eWxlczogW10sXG4gICAgICAgIGNzc01vZHVsZUNsYXNzZXM6IFtdLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja0NvbnRlbnQgPSBgXG4gICAgICAgIGltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG4gICAgICAgIFxuICAgICAgICBleHBvcnQgY29uc3QgQ3VzdG9tID0gKCkgPT4ge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICB7LyogY3VzdG9tICovfVxuICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cImJnLWJsdWUtNTAwXCI+T3JpZ2luYWw8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgICBgO1xuXG4gICAgICAoZnMucHJvbWlzZXMucmVhZEZpbGUgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrQ29udGVudCk7XG5cbiAgICAgIGNvbnN0IGNoYW5nZXMgPSBhd2FpdCByZWZhY3Rvci5hcHBseVRhaWx3aW5kVHJhbnNmb3JtYXRpb25zKFttb2NrQ29tcG9uZW50XSwgY2xhc3NNYXBwaW5nKTtcblxuICAgICAgZXhwZWN0KGNoYW5nZXMubGVuZ3RoKS50b0JlKDEpO1xuICAgICAgLy8gQ3VzdG9tIG92ZXJyaWRlIGxpbmUgc2hvdWxkIGJlIHByZXNlcnZlZFxuICAgICAgZXhwZWN0KGNoYW5nZXNbMF0uY29udGVudCkudG9Db250YWluKCcvKiBjdXN0b20gKi8nKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3JlZmFjdG9yQ29tcG9uZW50cycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiByZWZhY3RvciBzdGF0aXN0aWNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY2xhc3NNYXBwaW5nOiBDbGFzc01hcHBpbmcgPSB7XG4gICAgICAgICdiZy1ibHVlLTUwMCc6ICdiZy1wcmltYXJ5LTUwMCcsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IGdsb2IgfSA9IHJlcXVpcmUoJ2dsb2InKTtcbiAgICAgIGdsb2IubW9ja1Jlc29sdmVkVmFsdWUoWycvbW9jay9wcm9qZWN0L0J1dHRvbi50c3gnXSk7XG5cbiAgICAgIGNvbnN0IG1vY2tDb250ZW50ID0gYFxuICAgICAgICBpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuICAgICAgICBleHBvcnQgY29uc3QgQnV0dG9uID0gKCkgPT4gPGJ1dHRvbiBjbGFzc05hbWU9XCJiZy1ibHVlLTUwMFwiPkNsaWNrPC9idXR0b24+O1xuICAgICAgYDtcblxuICAgICAgKGZzLnByb21pc2VzLnJlYWRGaWxlIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUobW9ja0NvbnRlbnQpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWZhY3Rvci5yZWZhY3RvckNvbXBvbmVudHMoY2xhc3NNYXBwaW5nKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5maWxlc1Byb2Nlc3NlZCkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY2hhbmdlcykudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChBcnJheS5pc0FycmF5KHJlc3VsdC5jaGFuZ2VzKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJtYXBwaW5ncyI6Ijs7QUFLQTtBQUNBQSxXQUFBLEdBQUtDLElBQUksQ0FBQyxJQUFJLENBQUM7QUFDZkQsV0FBQSxHQUFLQyxJQUFJLENBQUMsTUFBTSxDQUFDO0FBUGpCLElBQUFDLHVCQUFBLEdBQUFDLE9BQUE7QUFFQSxJQUFBQyxFQUFBLEdBQUFDLHVCQUFBLENBQUFGLE9BQUE7QUFBeUIsU0FBQUUsd0JBQUFDLENBQUEsRUFBQUMsQ0FBQSw2QkFBQUMsT0FBQSxNQUFBQyxDQUFBLE9BQUFELE9BQUEsSUFBQUUsQ0FBQSxPQUFBRixPQUFBLFlBQUFILHVCQUFBLFlBQUFBLENBQUFDLENBQUEsRUFBQUMsQ0FBQSxTQUFBQSxDQUFBLElBQUFELENBQUEsSUFBQUEsQ0FBQSxDQUFBSyxVQUFBLFNBQUFMLENBQUEsTUFBQU0sQ0FBQSxFQUFBQyxDQUFBLEVBQUFDLENBQUEsS0FBQUMsU0FBQSxRQUFBQyxPQUFBLEVBQUFWLENBQUEsaUJBQUFBLENBQUEsdUJBQUFBLENBQUEseUJBQUFBLENBQUEsU0FBQVEsQ0FBQSxNQUFBRixDQUFBLEdBQUFM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