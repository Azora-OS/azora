import * as fs from 'fs';

interface CoverageData {
  lines: { total: number; covered: number; pct: number };
  statements: { total: number; covered: number; pct: number };
  functions: { total: number; covered: number; pct: number };
  branches: { total: number; covered: number; pct: number };
}

interface TestResults {
  numTotalTests: number;
  numPassedTests: number;
  numFailedTests: number;
  numPendingTests: number;
  success: boolean;
}

class PRCommentGenerator {
  generateCoverageComment(
    currentCoverage: CoverageData,
    previousCoverage?: CoverageData
  ): string {
    const lines = [
      '## üìä Test Coverage Report',
      '',
      '| Metric | Coverage | Change |',
      '|--------|----------|--------|',
    ];

    const metrics: (keyof CoverageData)[] = ['lines', 'statements', 'functions', 'branches'];

    metrics.forEach(metric => {
      const current = currentCoverage[metric].pct;
      const emoji = this.getCoverageEmoji(current);

      let changeStr = '-';
      if (previousCoverage) {
        const previous = previousCoverage[metric].pct;
        const change = current - previous;
        changeStr = this.formatChange(change);
      }

      lines.push(`| ${metric.charAt(0).toUpperCase() + metric.slice(1)} | ${emoji} ${current.toFixed(2)}% | ${changeStr} |`);
    });

    lines.push('');

    return lines.join('\n');
  }

  generateTestResultsComment(results: TestResults): string {
    const lines = [
      '## üß™ Test Results',
      '',
      `- **Total Tests:** ${results.numTotalTests}`,
      `- **Passed:** ‚úÖ ${results.numPassedTests}`,
      `- **Failed:** ‚ùå ${results.numFailedTests}`,
      `- **Pending:** ‚è∏Ô∏è ${results.numPendingTests}`,
      '',
    ];

    if (results.success) {
      lines.push('‚úÖ All tests passed!');
    } else {
      lines.push('‚ùå Some tests failed. Please review the test results.');
    }

    lines.push('');

    return lines.join('\n');
  }

  generateFullComment(
    testResults: TestResults,
    currentCoverage: CoverageData,
    previousCoverage?: CoverageData
  ): string {
    const lines = [
      '# Test Suite Results',
      '',
    ];

    lines.push(this.generateTestResultsComment(testResults));
    lines.push(this.generateCoverageComment(currentCoverage, previousCoverage));

    if (previousCoverage) {
      lines.push(this.generateCoverageComparison(currentCoverage, previousCoverage));
    }

    lines.push('---');
    lines.push('*This comment was automatically generated by the test suite*');

    return lines.join('\n');
  }

  private generateCoverageComparison(current: CoverageData, previous: CoverageData): string {
    const lines = [
      '### Coverage Changes',
      '',
    ];

    const metrics: (keyof CoverageData)[] = ['lines', 'statements', 'functions', 'branches'];
    let hasChanges = false;

    metrics.forEach(metric => {
      const change = current[metric].pct - previous[metric].pct;

      if (Math.abs(change) > 0.1) {
        hasChanges = true;
        const emoji = change > 0 ? 'üìà' : 'üìâ';
        lines.push(`${emoji} **${metric}**: ${this.formatChange(change)}`);
      }
    });

    if (!hasChanges) {
      lines.push('No significant coverage changes');
    }

    lines.push('');

    return lines.join('\n');
  }

  private getCoverageEmoji(coverage: number): string {
    if (coverage >= 80) return 'üü¢';
    if (coverage >= 60) return 'üü°';
    if (coverage >= 40) return 'üü†';
    return 'üî¥';
  }

  private formatChange(change: number): string {
    const sign = change >= 0 ? '+' : '';
    const emoji = change > 0 ? '‚¨ÜÔ∏è' : change < 0 ? '‚¨áÔ∏è' : '‚û°Ô∏è';
    return `${emoji} ${sign}${change.toFixed(2)}%`;
  }
}

async function main() {
  const coverageSummaryPath = './tests/coverage/coverage-summary.json';
  const testResultsPath = './test-results.json';

  if (!fs.existsSync(coverageSummaryPath)) {
    console.error('Coverage summary not found');
    process.exit(1);
  }

  const coverageData = JSON.parse(fs.readFileSync(coverageSummaryPath, 'utf-8'));
  const currentCoverage = coverageData.total;

  let testResults: TestResults = {
    numTotalTests: 0,
    numPassedTests: 0,
    numFailedTests: 0,
    numPendingTests: 0,
    success: true,
  };

  if (fs.existsSync(testResultsPath)) {
    testResults = JSON.parse(fs.readFileSync(testResultsPath, 'utf-8'));
  }

  const generator = new PRCommentGenerator();
  const comment = generator.generateFullComment(testResults, currentCoverage);

  console.log(comment);

  fs.writeFileSync('./pr-comment.md', comment);
}

if (require.main === module) {
  main().catch(error => {
    console.error('Error generating PR comment:', error);
    process.exit(1);
  });
}

export { PRCommentGenerator };
