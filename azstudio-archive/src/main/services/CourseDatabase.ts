import { FileChange } from './ChangesetManager';
import * as path from 'path';

export interface PrismaSchemaOptions {
  includeEnrollment?: boolean;
  includeProgress?: boolean;
  includeCertificates?: boolean;
  includeAssessments?: boolean;
  includeDiscussions?: boolean;
}

export interface EnrollmentTracking {
  enrollmentDate: boolean;
  completionDate: boolean;
  status: boolean;
  progress: boolean;
}

export interface ProgressTracking {
  lessonProgress: boolean;
  quizScores: boolean;
  codeExerciseSubmissions: boolean;
  timeSpent: boolean;
  lastAccessed: boolean;
}

export interface CertificateSystem {
  certificateGeneration: boolean;
  completionCriteria: boolean;
  certificateTemplates: boolean;
  verification: boolean;
}

export class CourseDatabaseGenerator {
  /**
   * Generate Prisma schema for course management
   */
  generatePrismaSchema(options: PrismaSchemaOptions = {}): string {
    const {
      includeEnrollment = true,
      includeProgress = true,
      includeCertificates = true,
      includeAssessments = true,
      includeDiscussions = false,
    } = options;

    let schema = `// Course Management Schema
// Generated by AzStudio Course Builder

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// User model (if not already defined)
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

${includeEnrollment ? '  enrollments Enrollment[]\n' : ''}${includeProgress ? '  progress    LessonProgress[]\n' : ''}${includeAssessments ? '  quizAttempts QuizAttempt[]\n  codeSubmissions CodeSubmission[]\n' : ''}${includeCertificates ? '  certificates Certificate[]\n' : ''}${includeDiscussions ? '  discussions Discussion[]\n  comments    Comment[]\n' : ''}
  @@map("users")
}

// Course model
model Course {
  id          String   @id @default(cuid())
  title       String
  description String   @db.Text
  instructor  String
  category    String
  level       String   // beginner, intermediate, advanced
  tags        String[]
  thumbnail   String?
  estimatedDuration Int? // in hours
  prerequisites String[]
  published   Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  modules     Module[]
${includeEnrollment ? '  enrollments Enrollment[]\n' : ''}${includeCertificates ? '  certificates Certificate[]\n' : ''}
  @@map("courses")
}

// Module model
model Module {
  id          String   @id @default(cuid())
  courseId    String
  title       String
  description String   @db.Text
  order       Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  course      Course   @relation(fields: [courseId], references: [id], onDelete: Cascade)
  lessons     Lesson[]

  @@map("modules")
  @@index([courseId])
}

// Lesson model
model Lesson {
  id          String   @id @default(cuid())
  moduleId    String
  title       String
  type        String   // video, text, quiz, code
  order       Int
  content     String?  @db.Text
  duration    Int?     // in minutes
  videoUrl    String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  module      Module   @relation(fields: [moduleId], references: [id], onDelete: Cascade)
${includeProgress ? '  progress    LessonProgress[]\n' : ''}  quizQuestions QuizQuestion[]
  codeExercises CodeExercise[]

  @@map("lessons")
  @@index([moduleId])
}

// Quiz Question model
model QuizQuestion {
  id          String   @id @default(cuid())
  lessonId    String
  question    String   @db.Text
  options     String[] // JSON array of options
  correctAnswer Int
  explanation String?  @db.Text
  order       Int
  createdAt   DateTime @default(now())

  lesson      Lesson   @relation(fields: [lessonId], references: [id], onDelete: Cascade)
${includeAssessments ? '  attempts    QuizAttempt[]\n' : ''}
  @@map("quiz_questions")
  @@index([lessonId])
}

// Code Exercise model
model CodeExercise {
  id          String   @id @default(cuid())
  lessonId    String
  description String   @db.Text
  starterCode String   @db.Text
  solution    String   @db.Text
  testCases   String[] // JSON array of test cases
  createdAt   DateTime @default(now())

  lesson      Lesson   @relation(fields: [lessonId], references: [id], onDelete: Cascade)
${includeAssessments ? '  submissions CodeSubmission[]\n' : ''}
  @@map("code_exercises")
  @@index([lessonId])
}
`;

    if (includeEnrollment) {
      schema += `
// Enrollment model
model Enrollment {
  id          String   @id @default(cuid())
  userId      String
  courseId    String
  status      String   @default("active") // active, completed, dropped
  progress    Float    @default(0) // 0-100
  enrolledAt  DateTime @default(now())
  completedAt DateTime?
  updatedAt   DateTime @updatedAt

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  course      Course   @relation(fields: [courseId], references: [id], onDelete: Cascade)

  @@unique([userId, courseId])
  @@map("enrollments")
  @@index([userId])
  @@index([courseId])
}
`;
    }

    if (includeProgress) {
      schema += `
// Lesson Progress model
model LessonProgress {
  id          String   @id @default(cuid())
  userId      String
  lessonId    String
  completed   Boolean  @default(false)
  timeSpent   Int      @default(0) // in seconds
  lastAccessed DateTime @default(now())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  lesson      Lesson   @relation(fields: [lessonId], references: [id], onDelete: Cascade)

  @@unique([userId, lessonId])
  @@map("lesson_progress")
  @@index([userId])
  @@index([lessonId])
}
`;
    }

    if (includeAssessments) {
      schema += `
// Quiz Attempt model
model QuizAttempt {
  id          String   @id @default(cuid())
  userId      String
  questionId  String
  selectedAnswer Int
  correct     Boolean
  attemptedAt DateTime @default(now())

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  question    QuizQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@map("quiz_attempts")
  @@index([userId])
  @@index([questionId])
}

// Code Submission model
model CodeSubmission {
  id          String   @id @default(cuid())
  userId      String
  exerciseId  String
  code        String   @db.Text
  passed      Boolean  @default(false)
  testResults String?  @db.Text // JSON
  submittedAt DateTime @default(now())

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  exercise    CodeExercise @relation(fields: [exerciseId], references: [id], onDelete: Cascade)

  @@map("code_submissions")
  @@index([userId])
  @@index([exerciseId])
}
`;
    }

    if (includeCertificates) {
      schema += `
// Certificate model
model Certificate {
  id          String   @id @default(cuid())
  userId      String
  courseId    String
  certificateNumber String @unique
  issuedAt    DateTime @default(now())
  verificationUrl String?
  pdfUrl      String?

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  course      Course   @relation(fields: [courseId], references: [id], onDelete: Cascade)

  @@unique([userId, courseId])
  @@map("certificates")
  @@index([userId])
  @@index([courseId])
}
`;
    }

    if (includeDiscussions) {
      schema += `
// Discussion model
model Discussion {
  id          String   @id @default(cuid())
  courseId    String
  userId      String
  title       String
  content     String   @db.Text
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  comments    Comment[]

  @@map("discussions")
  @@index([courseId])
  @@index([userId])
}

// Comment model
model Comment {
  id          String   @id @default(cuid())
  discussionId String
  userId      String
  content     String   @db.Text
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  discussion  Discussion @relation(fields: [discussionId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("comments")
  @@index([discussionId])
  @@index([userId])
}
`;
    }

    return schema;
  }

  /**
   * Generate enrollment tracking service
   */
  generateEnrollmentService(): string {
    return `import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export class EnrollmentService {
  /**
   * Enroll a user in a course
   */
  async enrollUser(userId: string, courseId: string) {
    return prisma.enrollment.create({
      data: {
        userId,
        courseId,
        status: 'active',
        progress: 0,
      },
      include: {
        course: true,
      },
    });
  }

  /**
   * Get user enrollments
   */
  async getUserEnrollments(userId: string) {
    return prisma.enrollment.findMany({
      where: { userId },
      include: {
        course: {
          include: {
            modules: {
              include: {
                lessons: true,
              },
            },
          },
        },
      },
      orderBy: {
        enrolledAt: 'desc',
      },
    });
  }

  /**
   * Get course enrollments
   */
  async getCourseEnrollments(courseId: string) {
    return prisma.enrollment.findMany({
      where: { courseId },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
      },
      orderBy: {
        enrolledAt: 'desc',
      },
    });
  }

  /**
   * Update enrollment progress
   */
  async updateProgress(userId: string, courseId: string, progress: number) {
    return prisma.enrollment.update({
      where: {
        userId_courseId: {
          userId,
          courseId,
        },
      },
      data: {
        progress,
        ...(progress >= 100 ? { status: 'completed', completedAt: new Date() } : {}),
      },
    });
  }

  /**
   * Check if user is enrolled
   */
  async isEnrolled(userId: string, courseId: string): Promise<boolean> {
    const enrollment = await prisma.enrollment.findUnique({
      where: {
        userId_courseId: {
          userId,
          courseId,
        },
      },
    });
    return !!enrollment;
  }

  /**
   * Unenroll user from course
   */
  async unenrollUser(userId: string, courseId: string) {
    return prisma.enrollment.update({
      where: {
        userId_courseId: {
          userId,
          courseId,
        },
      },
      data: {
        status: 'dropped',
      },
    });
  }
}
`;
  }

  /**
   * Generate progress tracking service
   */
  generateProgressService(): string {
    return `import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export class ProgressService {
  /**
   * Mark lesson as completed
   */
  async completeLesson(userId: string, lessonId: string, timeSpent: number = 0) {
    return prisma.lessonProgress.upsert({
      where: {
        userId_lessonId: {
          userId,
          lessonId,
        },
      },
      update: {
        completed: true,
        timeSpent,
        lastAccessed: new Date(),
      },
      create: {
        userId,
        lessonId,
        completed: true,
        timeSpent,
      },
    });
  }

  /**
   * Update lesson progress
   */
  async updateLessonProgress(userId: string, lessonId: string, timeSpent: number) {
    return prisma.lessonProgress.upsert({
      where: {
        userId_lessonId: {
          userId,
          lessonId,
        },
      },
      update: {
        timeSpent: {
          increment: timeSpent,
        },
        lastAccessed: new Date(),
      },
      create: {
        userId,
        lessonId,
        timeSpent,
        completed: false,
      },
    });
  }

  /**
   * Get user progress for a course
   */
  async getCourseProgress(userId: string, courseId: string) {
    const course = await prisma.course.findUnique({
      where: { id: courseId },
      include: {
        modules: {
          include: {
            lessons: {
              include: {
                progress: {
                  where: { userId },
                },
              },
            },
          },
        },
      },
    });

    if (!course) return null;

    const totalLessons = course.modules.reduce(
      (sum, module) => sum + module.lessons.length,
      0
    );
    const completedLessons = course.modules.reduce(
      (sum, module) =>
        sum + module.lessons.filter((lesson) => lesson.progress[0]?.completed).length,
      0
    );

    return {
      courseId,
      totalLessons,
      completedLessons,
      progress: totalLessons > 0 ? (completedLessons / totalLessons) * 100 : 0,
      modules: course.modules.map((module) => ({
        moduleId: module.id,
        title: module.title,
        totalLessons: module.lessons.length,
        completedLessons: module.lessons.filter(
          (lesson) => lesson.progress[0]?.completed
        ).length,
        lessons: module.lessons.map((lesson) => ({
          lessonId: lesson.id,
          title: lesson.title,
          completed: lesson.progress[0]?.completed || false,
          timeSpent: lesson.progress[0]?.timeSpent || 0,
          lastAccessed: lesson.progress[0]?.lastAccessed,
        })),
      })),
    };
  }

  /**
   * Get user's overall progress across all courses
   */
  async getUserOverallProgress(userId: string) {
    const enrollments = await prisma.enrollment.findMany({
      where: { userId },
      include: {
        course: {
          include: {
            modules: {
              include: {
                lessons: {
                  include: {
                    progress: {
                      where: { userId },
                    },
                  },
                },
              },
            },
          },
        },
      },
    });

    return enrollments.map((enrollment) => {
      const totalLessons = enrollment.course.modules.reduce(
        (sum, module) => sum + module.lessons.length,
        0
      );
      const completedLessons = enrollment.course.modules.reduce(
        (sum, module) =>
          sum + module.lessons.filter((lesson) => lesson.progress[0]?.completed).length,
        0
      );

      return {
        courseId: enrollment.courseId,
        courseTitle: enrollment.course.title,
        progress: totalLessons > 0 ? (completedLessons / totalLessons) * 100 : 0,
        enrolledAt: enrollment.enrolledAt,
        completedAt: enrollment.completedAt,
        status: enrollment.status,
      };
    });
  }
}
`;
  }

  /**
   * Generate certificate service
   */
  generateCertificateService(): string {
    return `import { PrismaClient } from '@prisma/client';
import { randomBytes } from 'crypto';

const prisma = new PrismaClient();

export class CertificateService {
  /**
   * Generate certificate for completed course
   */
  async generateCertificate(userId: string, courseId: string) {
    // Check if course is completed
    const enrollment = await prisma.enrollment.findUnique({
      where: {
        userId_courseId: {
          userId,
          courseId,
        },
      },
      include: {
        user: true,
        course: true,
      },
    });

    if (!enrollment || enrollment.progress < 100) {
      throw new Error('Course not completed');
    }

    // Check if certificate already exists
    const existing = await prisma.certificate.findUnique({
      where: {
        userId_courseId: {
          userId,
          courseId,
        },
      },
    });

    if (existing) {
      return existing;
    }

    // Generate unique certificate number
    const certificateNumber = this.generateCertificateNumber();
    const verificationUrl = \`https://yourplatform.com/verify/\${certificateNumber}\`;

    return prisma.certificate.create({
      data: {
        userId,
        courseId,
        certificateNumber,
        verificationUrl,
      },
      include: {
        user: true,
        course: true,
      },
    });
  }

  /**
   * Verify certificate
   */
  async verifyCertificate(certificateNumber: string) {
    return prisma.certificate.findUnique({
      where: { certificateNumber },
      include: {
        user: {
          select: {
            name: true,
            email: true,
          },
        },
        course: {
          select: {
            title: true,
            instructor: true,
          },
        },
      },
    });
  }

  /**
   * Get user certificates
   */
  async getUserCertificates(userId: string) {
    return prisma.certificate.findMany({
      where: { userId },
      include: {
        course: {
          select: {
            title: true,
            instructor: true,
            category: true,
          },
        },
      },
      orderBy: {
        issuedAt: 'desc',
      },
    });
  }

  /**
   * Generate unique certificate number
   */
  private generateCertificateNumber(): string {
    const timestamp = Date.now().toString(36).toUpperCase();
    const random = randomBytes(4).toString('hex').toUpperCase();
    return \`CERT-\${timestamp}-\${random}\`;
  }
}
`;
  }

  /**
   * Generate all course database files
   */
  generateDatabaseFiles(outputDir: string, options: PrismaSchemaOptions = {}): FileChange[] {
    const changes: FileChange[] = [];

    // Generate Prisma schema
    const schemaPath = path.join(outputDir, 'prisma', 'schema.prisma');
    changes.push({
      path: schemaPath,
      type: 'create',
      content: this.generatePrismaSchema(options),
    });

    // Generate enrollment service
    if (options.includeEnrollment !== false) {
      const enrollmentPath = path.join(outputDir, 'services', 'enrollment.service.ts');
      changes.push({
        path: enrollmentPath,
        type: 'create',
        content: this.generateEnrollmentService(),
      });
    }

    // Generate progress service
    if (options.includeProgress !== false) {
      const progressPath = path.join(outputDir, 'services', 'progress.service.ts');
      changes.push({
        path: progressPath,
        type: 'create',
        content: this.generateProgressService(),
      });
    }

    // Generate certificate service
    if (options.includeCertificates !== false) {
      const certificatePath = path.join(outputDir, 'services', 'certificate.service.ts');
      changes.push({
        path: certificatePath,
        type: 'create',
        content: this.generateCertificateService(),
      });
    }

    return changes;
  }
}
